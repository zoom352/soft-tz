{"ast":null,"code":"import { $PROXY, getListener, batch, createSignal } from 'solid-js';\nconst $RAW = Symbol(\"store-raw\"),\n      $NODE = Symbol(\"store-node\"),\n      $NAME = Symbol(\"store-name\");\n\nfunction wrap$1(value, name) {\n  let p = value[$PROXY];\n\n  if (!p) {\n    Object.defineProperty(value, $PROXY, {\n      value: p = new Proxy(value, proxyTraps$1)\n    });\n    const keys = Object.keys(value),\n          desc = Object.getOwnPropertyDescriptors(value);\n\n    for (let i = 0, l = keys.length; i < l; i++) {\n      const prop = keys[i];\n\n      if (desc[prop].get) {\n        const get = desc[prop].get.bind(p);\n        Object.defineProperty(value, prop, {\n          get\n        });\n      }\n    }\n  }\n\n  return p;\n}\n\nfunction isWrappable(obj) {\n  return obj != null && typeof obj === \"object\" && (obj[$PROXY] || !obj.__proto__ || obj.__proto__ === Object.prototype || Array.isArray(obj));\n}\n\nfunction unwrap(item) {\n  let set = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n  let result, unwrapped, v, prop;\n  if (result = item != null && item[$RAW]) return result;\n  if (!isWrappable(item) || set.has(item)) return item;\n\n  if (Array.isArray(item)) {\n    if (Object.isFrozen(item)) item = item.slice(0);else set.add(item);\n\n    for (let i = 0, l = item.length; i < l; i++) {\n      v = item[i];\n      if ((unwrapped = unwrap(v, set)) !== v) item[i] = unwrapped;\n    }\n  } else {\n    if (Object.isFrozen(item)) item = Object.assign({}, item);else set.add(item);\n    const keys = Object.keys(item),\n          desc = Object.getOwnPropertyDescriptors(item);\n\n    for (let i = 0, l = keys.length; i < l; i++) {\n      prop = keys[i];\n      if (desc[prop].get) continue;\n      v = item[prop];\n      if ((unwrapped = unwrap(v, set)) !== v) item[prop] = unwrapped;\n    }\n  }\n\n  return item;\n}\n\nfunction getDataNodes(target) {\n  let nodes = target[$NODE];\n  if (!nodes) Object.defineProperty(target, $NODE, {\n    value: nodes = {}\n  });\n  return nodes;\n}\n\nfunction proxyDescriptor(target, property) {\n  const desc = Reflect.getOwnPropertyDescriptor(target, property);\n  if (!desc || desc.get || !desc.configurable || property === $PROXY || property === $NODE || property === $NAME) return desc;\n  delete desc.value;\n  delete desc.writable;\n\n  desc.get = () => target[$PROXY][property];\n\n  return desc;\n}\n\nfunction ownKeys(target) {\n  if (getListener()) {\n    const nodes = getDataNodes(target);\n    (nodes._ || (nodes._ = createDataNode()))();\n  }\n\n  return Reflect.ownKeys(target);\n}\n\nfunction createDataNode() {\n  const [s, set] = createSignal(undefined, {\n    equals: false,\n    internal: true\n  });\n  s.$ = set;\n  return s;\n}\n\nconst proxyTraps$1 = {\n  get(target, property, receiver) {\n    if (property === $RAW) return target;\n    if (property === $PROXY) return receiver;\n    const value = target[property];\n    if (property === $NODE || property === \"__proto__\") return value;\n    const wrappable = isWrappable(value);\n\n    if (getListener() && (typeof value !== \"function\" || target.hasOwnProperty(property))) {\n      let nodes, node;\n\n      if (wrappable && (nodes = getDataNodes(value))) {\n        node = nodes._ || (nodes._ = createDataNode());\n        node();\n      }\n\n      nodes = getDataNodes(target);\n      node = nodes[property] || (nodes[property] = createDataNode());\n      node();\n    }\n\n    return wrappable ? wrap$1(value) : value;\n  },\n\n  set() {\n    return true;\n  },\n\n  deleteProperty() {\n    return true;\n  },\n\n  ownKeys: ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor\n};\n\nfunction setProperty(state, property, value) {\n  if (state[property] === value) return;\n  const array = Array.isArray(state);\n  const len = state.length;\n  const isUndefined = value === undefined;\n  const notify = array || isUndefined === property in state;\n\n  if (isUndefined) {\n    delete state[property];\n  } else state[property] = value;\n\n  let nodes = getDataNodes(state),\n      node;\n  (node = nodes[property]) && node.$();\n  if (array && state.length !== len) (node = nodes.length) && node.$();\n  notify && (node = nodes._) && node.$();\n}\n\nfunction mergeStoreNode(state, value) {\n  const keys = Object.keys(value);\n\n  for (let i = 0; i < keys.length; i += 1) {\n    const key = keys[i];\n    setProperty(state, key, value[key]);\n  }\n}\n\nfunction updatePath(current, path) {\n  let traversed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let part,\n      prev = current;\n\n  if (path.length > 1) {\n    part = path.shift();\n    const partType = typeof part,\n          isArray = Array.isArray(current);\n\n    if (Array.isArray(part)) {\n      for (let i = 0; i < part.length; i++) {\n        updatePath(current, [part[i]].concat(path), [part[i]].concat(traversed));\n      }\n\n      return;\n    } else if (isArray && partType === \"function\") {\n      for (let i = 0; i < current.length; i++) {\n        if (part(current[i], i)) updatePath(current, [i].concat(path), [i].concat(traversed));\n      }\n\n      return;\n    } else if (isArray && partType === \"object\") {\n      const {\n        from = 0,\n        to = current.length - 1,\n        by = 1\n      } = part;\n\n      for (let i = from; i <= to; i += by) {\n        updatePath(current, [i].concat(path), [i].concat(traversed));\n      }\n\n      return;\n    } else if (path.length > 1) {\n      updatePath(current[part], path, [part].concat(traversed));\n      return;\n    }\n\n    prev = current[part];\n    traversed = [part].concat(traversed);\n  }\n\n  let value = path[0];\n\n  if (typeof value === \"function\") {\n    value = value(prev, traversed);\n    if (value === prev) return;\n  }\n\n  if (part === undefined && value == undefined) return;\n  value = unwrap(value);\n\n  if (part === undefined || isWrappable(prev) && isWrappable(value) && !Array.isArray(value)) {\n    mergeStoreNode(prev, value);\n  } else setProperty(current, part, value);\n}\n\nfunction createStore(store, options) {\n  const unwrappedStore = unwrap(store || {});\n  const wrappedStore = wrap$1(unwrappedStore);\n\n  function setStore() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    batch(() => updatePath(unwrappedStore, args));\n  }\n\n  return [wrappedStore, setStore];\n}\n\nconst proxyTraps = {\n  get(target, property, receiver) {\n    if (property === $RAW) return target;\n    if (property === $PROXY) return receiver;\n    const value = target[property];\n    if (property === $NODE || property === \"__proto__\") return value;\n    const wrappable = isWrappable(value);\n\n    if (getListener() && (typeof value !== \"function\" || target.hasOwnProperty(property))) {\n      let nodes, node;\n\n      if (wrappable && (nodes = getDataNodes(value))) {\n        node = nodes._ || (nodes._ = createDataNode());\n        node();\n      }\n\n      nodes = getDataNodes(target);\n      node = nodes[property] || (nodes[property] = createDataNode());\n      node();\n    }\n\n    return wrappable ? wrap(value) : value;\n  },\n\n  set(target, property, value) {\n    setProperty(target, property, unwrap(value));\n    return true;\n  },\n\n  deleteProperty(target, property) {\n    setProperty(target, property, undefined);\n    return true;\n  },\n\n  ownKeys: ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor\n};\n\nfunction wrap(value, name) {\n  let p = value[$PROXY];\n\n  if (!p) {\n    Object.defineProperty(value, $PROXY, {\n      value: p = new Proxy(value, proxyTraps)\n    });\n    const keys = Object.keys(value),\n          desc = Object.getOwnPropertyDescriptors(value);\n\n    for (let i = 0, l = keys.length; i < l; i++) {\n      const prop = keys[i];\n\n      if (desc[prop].get) {\n        const get = desc[prop].get.bind(p);\n        Object.defineProperty(value, prop, {\n          get\n        });\n      }\n\n      if (desc[prop].set) {\n        const og = desc[prop].set,\n              set = v => batch(() => og.call(p, v));\n\n        Object.defineProperty(value, prop, {\n          set\n        });\n      }\n    }\n  }\n\n  return p;\n}\n\nfunction createMutable(state, options) {\n  const unwrappedStore = unwrap(state || {});\n  const wrappedStore = wrap(unwrappedStore);\n  return wrappedStore;\n}\n\nfunction applyState(target, parent, property, merge, key) {\n  const previous = parent[property];\n  if (target === previous) return;\n\n  if (!isWrappable(target) || !isWrappable(previous) || key && target[key] !== previous[key]) {\n    target !== previous && setProperty(parent, property, target);\n    return;\n  }\n\n  if (Array.isArray(target)) {\n    if (target.length && previous.length && (!merge || key && target[0][key] != null)) {\n      let i, j, start, end, newEnd, item, newIndicesNext, keyVal;\n\n      for (start = 0, end = Math.min(previous.length, target.length); start < end && (previous[start] === target[start] || key && previous[start][key] === target[start][key]); start++) {\n        applyState(target[start], previous, start, merge, key);\n      }\n\n      const temp = new Array(target.length),\n            newIndices = new Map();\n\n      for (end = previous.length - 1, newEnd = target.length - 1; end >= start && newEnd >= start && (previous[end] === target[newEnd] || key && previous[end][key] === target[newEnd][key]); end--, newEnd--) {\n        temp[newEnd] = previous[end];\n      }\n\n      if (start > newEnd || start > end) {\n        for (j = start; j <= newEnd; j++) setProperty(previous, j, target[j]);\n\n        for (; j < target.length; j++) {\n          setProperty(previous, j, temp[j]);\n          applyState(target[j], previous, j, merge, key);\n        }\n\n        if (previous.length > target.length) setProperty(previous, \"length\", target.length);\n        return;\n      }\n\n      newIndicesNext = new Array(newEnd + 1);\n\n      for (j = newEnd; j >= start; j--) {\n        item = target[j];\n        keyVal = key ? item[key] : item;\n        i = newIndices.get(keyVal);\n        newIndicesNext[j] = i === undefined ? -1 : i;\n        newIndices.set(keyVal, j);\n      }\n\n      for (i = start; i <= end; i++) {\n        item = previous[i];\n        keyVal = key ? item[key] : item;\n        j = newIndices.get(keyVal);\n\n        if (j !== undefined && j !== -1) {\n          temp[j] = previous[i];\n          j = newIndicesNext[j];\n          newIndices.set(keyVal, j);\n        }\n      }\n\n      for (j = start; j < target.length; j++) {\n        if (j in temp) {\n          setProperty(previous, j, temp[j]);\n          applyState(target[j], previous, j, merge, key);\n        } else setProperty(previous, j, target[j]);\n      }\n    } else {\n      for (let i = 0, len = target.length; i < len; i++) {\n        applyState(target[i], previous, i, merge, key);\n      }\n    }\n\n    if (previous.length > target.length) setProperty(previous, \"length\", target.length);\n    return;\n  }\n\n  const targetKeys = Object.keys(target);\n\n  for (let i = 0, len = targetKeys.length; i < len; i++) {\n    applyState(target[targetKeys[i]], previous, targetKeys[i], merge, key);\n  }\n\n  const previousKeys = Object.keys(previous);\n\n  for (let i = 0, len = previousKeys.length; i < len; i++) {\n    if (target[previousKeys[i]] === undefined) setProperty(previous, previousKeys[i], undefined);\n  }\n}\n\nfunction reconcile(value) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    merge,\n    key = \"id\"\n  } = options,\n        v = unwrap(value);\n  return s => {\n    const state = s;\n    if (!isWrappable(state) || !isWrappable(v)) return v;\n    applyState(v, {\n      state\n    }, \"state\", merge, key);\n    return state;\n  };\n}\n\nconst setterTraps = {\n  get(target, property) {\n    if (property === $RAW) return target;\n    const value = target[property];\n    return isWrappable(value) ? new Proxy(value, setterTraps) : value;\n  },\n\n  set(target, property, value) {\n    setProperty(target, property, unwrap(value));\n    return true;\n  },\n\n  deleteProperty(target, property) {\n    setProperty(target, property, undefined);\n    return true;\n  }\n\n};\n\nfunction produce(fn) {\n  return s => {\n    const state = s;\n    if (isWrappable(state)) fn(new Proxy(state, setterTraps));\n    return state;\n  };\n}\n\nexport { $RAW, createMutable, createStore, produce, reconcile, unwrap };","map":{"version":3,"sources":["C:/dragon-drop/node_modules/solid-js/store/dist/store.js"],"names":["$PROXY","getListener","batch","createSignal","$RAW","Symbol","$NODE","$NAME","wrap$1","value","name","p","Object","defineProperty","Proxy","proxyTraps$1","keys","desc","getOwnPropertyDescriptors","i","l","length","prop","get","bind","isWrappable","obj","__proto__","prototype","Array","isArray","unwrap","item","set","Set","result","unwrapped","v","has","isFrozen","slice","add","assign","getDataNodes","target","nodes","proxyDescriptor","property","Reflect","getOwnPropertyDescriptor","configurable","writable","ownKeys","_","createDataNode","s","undefined","equals","internal","$","receiver","wrappable","hasOwnProperty","node","deleteProperty","setProperty","state","array","len","isUndefined","notify","mergeStoreNode","key","updatePath","current","path","traversed","part","prev","shift","partType","concat","from","to","by","createStore","store","options","unwrappedStore","wrappedStore","setStore","args","proxyTraps","wrap","og","call","createMutable","applyState","parent","merge","previous","j","start","end","newEnd","newIndicesNext","keyVal","Math","min","temp","newIndices","Map","targetKeys","previousKeys","reconcile","setterTraps","produce","fn"],"mappings":"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","sourcesContent":["import { $PROXY, getListener, batch, createSignal } from 'solid-js';\n\nconst $RAW = Symbol(\"store-raw\"),\n      $NODE = Symbol(\"store-node\"),\n      $NAME = Symbol(\"store-name\");\nfunction wrap$1(value, name) {\n  let p = value[$PROXY];\n  if (!p) {\n    Object.defineProperty(value, $PROXY, {\n      value: p = new Proxy(value, proxyTraps$1)\n    });\n    const keys = Object.keys(value),\n          desc = Object.getOwnPropertyDescriptors(value);\n    for (let i = 0, l = keys.length; i < l; i++) {\n      const prop = keys[i];\n      if (desc[prop].get) {\n        const get = desc[prop].get.bind(p);\n        Object.defineProperty(value, prop, {\n          get\n        });\n      }\n    }\n  }\n  return p;\n}\nfunction isWrappable(obj) {\n  return obj != null && typeof obj === \"object\" && (obj[$PROXY] || !obj.__proto__ || obj.__proto__ === Object.prototype || Array.isArray(obj));\n}\nfunction unwrap(item, set = new Set()) {\n  let result, unwrapped, v, prop;\n  if (result = item != null && item[$RAW]) return result;\n  if (!isWrappable(item) || set.has(item)) return item;\n  if (Array.isArray(item)) {\n    if (Object.isFrozen(item)) item = item.slice(0);else set.add(item);\n    for (let i = 0, l = item.length; i < l; i++) {\n      v = item[i];\n      if ((unwrapped = unwrap(v, set)) !== v) item[i] = unwrapped;\n    }\n  } else {\n    if (Object.isFrozen(item)) item = Object.assign({}, item);else set.add(item);\n    const keys = Object.keys(item),\n          desc = Object.getOwnPropertyDescriptors(item);\n    for (let i = 0, l = keys.length; i < l; i++) {\n      prop = keys[i];\n      if (desc[prop].get) continue;\n      v = item[prop];\n      if ((unwrapped = unwrap(v, set)) !== v) item[prop] = unwrapped;\n    }\n  }\n  return item;\n}\nfunction getDataNodes(target) {\n  let nodes = target[$NODE];\n  if (!nodes) Object.defineProperty(target, $NODE, {\n    value: nodes = {}\n  });\n  return nodes;\n}\nfunction proxyDescriptor(target, property) {\n  const desc = Reflect.getOwnPropertyDescriptor(target, property);\n  if (!desc || desc.get || !desc.configurable || property === $PROXY || property === $NODE || property === $NAME) return desc;\n  delete desc.value;\n  delete desc.writable;\n  desc.get = () => target[$PROXY][property];\n  return desc;\n}\nfunction ownKeys(target) {\n  if (getListener()) {\n    const nodes = getDataNodes(target);\n    (nodes._ || (nodes._ = createDataNode()))();\n  }\n  return Reflect.ownKeys(target);\n}\nfunction createDataNode() {\n  const [s, set] = createSignal(undefined, {\n    equals: false,\n    internal: true\n  });\n  s.$ = set;\n  return s;\n}\nconst proxyTraps$1 = {\n  get(target, property, receiver) {\n    if (property === $RAW) return target;\n    if (property === $PROXY) return receiver;\n    const value = target[property];\n    if (property === $NODE || property === \"__proto__\") return value;\n    const wrappable = isWrappable(value);\n    if (getListener() && (typeof value !== \"function\" || target.hasOwnProperty(property))) {\n      let nodes, node;\n      if (wrappable && (nodes = getDataNodes(value))) {\n        node = nodes._ || (nodes._ = createDataNode());\n        node();\n      }\n      nodes = getDataNodes(target);\n      node = nodes[property] || (nodes[property] = createDataNode());\n      node();\n    }\n    return wrappable ? wrap$1(value) : value;\n  },\n  set() {\n    return true;\n  },\n  deleteProperty() {\n    return true;\n  },\n  ownKeys: ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor\n};\nfunction setProperty(state, property, value) {\n  if (state[property] === value) return;\n  const array = Array.isArray(state);\n  const len = state.length;\n  const isUndefined = value === undefined;\n  const notify = array || isUndefined === property in state;\n  if (isUndefined) {\n    delete state[property];\n  } else state[property] = value;\n  let nodes = getDataNodes(state),\n      node;\n  (node = nodes[property]) && node.$();\n  if (array && state.length !== len) (node = nodes.length) && node.$();\n  notify && (node = nodes._) && node.$();\n}\nfunction mergeStoreNode(state, value) {\n  const keys = Object.keys(value);\n  for (let i = 0; i < keys.length; i += 1) {\n    const key = keys[i];\n    setProperty(state, key, value[key]);\n  }\n}\nfunction updatePath(current, path, traversed = []) {\n  let part,\n      prev = current;\n  if (path.length > 1) {\n    part = path.shift();\n    const partType = typeof part,\n          isArray = Array.isArray(current);\n    if (Array.isArray(part)) {\n      for (let i = 0; i < part.length; i++) {\n        updatePath(current, [part[i]].concat(path), [part[i]].concat(traversed));\n      }\n      return;\n    } else if (isArray && partType === \"function\") {\n      for (let i = 0; i < current.length; i++) {\n        if (part(current[i], i)) updatePath(current, [i].concat(path), [i].concat(traversed));\n      }\n      return;\n    } else if (isArray && partType === \"object\") {\n      const {\n        from = 0,\n        to = current.length - 1,\n        by = 1\n      } = part;\n      for (let i = from; i <= to; i += by) {\n        updatePath(current, [i].concat(path), [i].concat(traversed));\n      }\n      return;\n    } else if (path.length > 1) {\n      updatePath(current[part], path, [part].concat(traversed));\n      return;\n    }\n    prev = current[part];\n    traversed = [part].concat(traversed);\n  }\n  let value = path[0];\n  if (typeof value === \"function\") {\n    value = value(prev, traversed);\n    if (value === prev) return;\n  }\n  if (part === undefined && value == undefined) return;\n  value = unwrap(value);\n  if (part === undefined || isWrappable(prev) && isWrappable(value) && !Array.isArray(value)) {\n    mergeStoreNode(prev, value);\n  } else setProperty(current, part, value);\n}\nfunction createStore(store, options) {\n  const unwrappedStore = unwrap(store || {});\n  const wrappedStore = wrap$1(unwrappedStore);\n  function setStore(...args) {\n    batch(() => updatePath(unwrappedStore, args));\n  }\n  return [wrappedStore, setStore];\n}\n\nconst proxyTraps = {\n  get(target, property, receiver) {\n    if (property === $RAW) return target;\n    if (property === $PROXY) return receiver;\n    const value = target[property];\n    if (property === $NODE || property === \"__proto__\") return value;\n    const wrappable = isWrappable(value);\n    if (getListener() && (typeof value !== \"function\" || target.hasOwnProperty(property))) {\n      let nodes, node;\n      if (wrappable && (nodes = getDataNodes(value))) {\n        node = nodes._ || (nodes._ = createDataNode());\n        node();\n      }\n      nodes = getDataNodes(target);\n      node = nodes[property] || (nodes[property] = createDataNode());\n      node();\n    }\n    return wrappable ? wrap(value) : value;\n  },\n  set(target, property, value) {\n    setProperty(target, property, unwrap(value));\n    return true;\n  },\n  deleteProperty(target, property) {\n    setProperty(target, property, undefined);\n    return true;\n  },\n  ownKeys: ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor\n};\nfunction wrap(value, name) {\n  let p = value[$PROXY];\n  if (!p) {\n    Object.defineProperty(value, $PROXY, {\n      value: p = new Proxy(value, proxyTraps)\n    });\n    const keys = Object.keys(value),\n          desc = Object.getOwnPropertyDescriptors(value);\n    for (let i = 0, l = keys.length; i < l; i++) {\n      const prop = keys[i];\n      if (desc[prop].get) {\n        const get = desc[prop].get.bind(p);\n        Object.defineProperty(value, prop, {\n          get\n        });\n      }\n      if (desc[prop].set) {\n        const og = desc[prop].set,\n              set = v => batch(() => og.call(p, v));\n        Object.defineProperty(value, prop, {\n          set\n        });\n      }\n    }\n  }\n  return p;\n}\nfunction createMutable(state, options) {\n  const unwrappedStore = unwrap(state || {});\n  const wrappedStore = wrap(unwrappedStore);\n  return wrappedStore;\n}\n\nfunction applyState(target, parent, property, merge, key) {\n  const previous = parent[property];\n  if (target === previous) return;\n  if (!isWrappable(target) || !isWrappable(previous) || key && target[key] !== previous[key]) {\n    target !== previous && setProperty(parent, property, target);\n    return;\n  }\n  if (Array.isArray(target)) {\n    if (target.length && previous.length && (!merge || key && target[0][key] != null)) {\n      let i, j, start, end, newEnd, item, newIndicesNext, keyVal;\n      for (start = 0, end = Math.min(previous.length, target.length); start < end && (previous[start] === target[start] || key && previous[start][key] === target[start][key]); start++) {\n        applyState(target[start], previous, start, merge, key);\n      }\n      const temp = new Array(target.length),\n            newIndices = new Map();\n      for (end = previous.length - 1, newEnd = target.length - 1; end >= start && newEnd >= start && (previous[end] === target[newEnd] || key && previous[end][key] === target[newEnd][key]); end--, newEnd--) {\n        temp[newEnd] = previous[end];\n      }\n      if (start > newEnd || start > end) {\n        for (j = start; j <= newEnd; j++) setProperty(previous, j, target[j]);\n        for (; j < target.length; j++) {\n          setProperty(previous, j, temp[j]);\n          applyState(target[j], previous, j, merge, key);\n        }\n        if (previous.length > target.length) setProperty(previous, \"length\", target.length);\n        return;\n      }\n      newIndicesNext = new Array(newEnd + 1);\n      for (j = newEnd; j >= start; j--) {\n        item = target[j];\n        keyVal = key ? item[key] : item;\n        i = newIndices.get(keyVal);\n        newIndicesNext[j] = i === undefined ? -1 : i;\n        newIndices.set(keyVal, j);\n      }\n      for (i = start; i <= end; i++) {\n        item = previous[i];\n        keyVal = key ? item[key] : item;\n        j = newIndices.get(keyVal);\n        if (j !== undefined && j !== -1) {\n          temp[j] = previous[i];\n          j = newIndicesNext[j];\n          newIndices.set(keyVal, j);\n        }\n      }\n      for (j = start; j < target.length; j++) {\n        if (j in temp) {\n          setProperty(previous, j, temp[j]);\n          applyState(target[j], previous, j, merge, key);\n        } else setProperty(previous, j, target[j]);\n      }\n    } else {\n      for (let i = 0, len = target.length; i < len; i++) {\n        applyState(target[i], previous, i, merge, key);\n      }\n    }\n    if (previous.length > target.length) setProperty(previous, \"length\", target.length);\n    return;\n  }\n  const targetKeys = Object.keys(target);\n  for (let i = 0, len = targetKeys.length; i < len; i++) {\n    applyState(target[targetKeys[i]], previous, targetKeys[i], merge, key);\n  }\n  const previousKeys = Object.keys(previous);\n  for (let i = 0, len = previousKeys.length; i < len; i++) {\n    if (target[previousKeys[i]] === undefined) setProperty(previous, previousKeys[i], undefined);\n  }\n}\nfunction reconcile(value, options = {}) {\n  const {\n    merge,\n    key = \"id\"\n  } = options,\n        v = unwrap(value);\n  return s => {\n    const state = s;\n    if (!isWrappable(state) || !isWrappable(v)) return v;\n    applyState(v, {\n      state\n    }, \"state\", merge, key);\n    return state;\n  };\n}\nconst setterTraps = {\n  get(target, property) {\n    if (property === $RAW) return target;\n    const value = target[property];\n    return isWrappable(value) ? new Proxy(value, setterTraps) : value;\n  },\n  set(target, property, value) {\n    setProperty(target, property, unwrap(value));\n    return true;\n  },\n  deleteProperty(target, property) {\n    setProperty(target, property, undefined);\n    return true;\n  }\n};\nfunction produce(fn) {\n  return s => {\n    const state = s;\n    if (isWrappable(state)) fn(new Proxy(state, setterTraps));\n    return state;\n  };\n}\n\nexport { $RAW, createMutable, createStore, produce, reconcile, unwrap };\n"]},"metadata":{},"sourceType":"module"}