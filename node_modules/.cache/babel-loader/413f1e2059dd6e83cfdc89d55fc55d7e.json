{"ast":null,"code":"let taskIdCounter = 1,\n    isCallbackScheduled = false,\n    isPerformingWork = false,\n    taskQueue = [],\n    currentTask = null,\n    shouldYieldToHost = null,\n    yieldInterval = 5,\n    deadline = 0,\n    maxYieldInterval = 300,\n    scheduleCallback = null,\n    scheduledCallback = null;\nconst maxSigned31BitInt = 1073741823;\n\nfunction setupScheduler() {\n  const channel = new MessageChannel(),\n        port = channel.port2;\n\n  scheduleCallback = () => port.postMessage(null);\n\n  channel.port1.onmessage = () => {\n    if (scheduledCallback !== null) {\n      const currentTime = performance.now();\n      deadline = currentTime + yieldInterval;\n      const hasTimeRemaining = true;\n\n      try {\n        const hasMoreWork = scheduledCallback(hasTimeRemaining, currentTime);\n\n        if (!hasMoreWork) {\n          scheduledCallback = null;\n        } else port.postMessage(null);\n      } catch (error) {\n        port.postMessage(null);\n        throw error;\n      }\n    }\n  };\n\n  if (navigator && navigator.scheduling && navigator.scheduling.isInputPending) {\n    const scheduling = navigator.scheduling;\n\n    shouldYieldToHost = () => {\n      const currentTime = performance.now();\n\n      if (currentTime >= deadline) {\n        if (scheduling.isInputPending()) {\n          return true;\n        }\n\n        return currentTime >= maxYieldInterval;\n      } else {\n        return false;\n      }\n    };\n  } else {\n    shouldYieldToHost = () => performance.now() >= deadline;\n  }\n}\n\nfunction enqueue(taskQueue, task) {\n  function findIndex() {\n    let m = 0;\n    let n = taskQueue.length - 1;\n\n    while (m <= n) {\n      const k = n + m >> 1;\n      const cmp = task.expirationTime - taskQueue[k].expirationTime;\n      if (cmp > 0) m = k + 1;else if (cmp < 0) n = k - 1;else return k;\n    }\n\n    return m;\n  }\n\n  taskQueue.splice(findIndex(), 0, task);\n}\n\nfunction requestCallback(fn, options) {\n  if (!scheduleCallback) setupScheduler();\n  let startTime = performance.now(),\n      timeout = maxSigned31BitInt;\n  if (options && options.timeout) timeout = options.timeout;\n  const newTask = {\n    id: taskIdCounter++,\n    fn,\n    startTime,\n    expirationTime: startTime + timeout\n  };\n  enqueue(taskQueue, newTask);\n\n  if (!isCallbackScheduled && !isPerformingWork) {\n    isCallbackScheduled = true;\n    scheduledCallback = flushWork;\n    scheduleCallback();\n  }\n\n  return newTask;\n}\n\nfunction cancelCallback(task) {\n  task.fn = null;\n}\n\nfunction flushWork(hasTimeRemaining, initialTime) {\n  isCallbackScheduled = false;\n  isPerformingWork = true;\n\n  try {\n    return workLoop(hasTimeRemaining, initialTime);\n  } finally {\n    currentTask = null;\n    isPerformingWork = false;\n  }\n}\n\nfunction workLoop(hasTimeRemaining, initialTime) {\n  let currentTime = initialTime;\n  currentTask = taskQueue[0] || null;\n\n  while (currentTask !== null) {\n    if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n      break;\n    }\n\n    const callback = currentTask.fn;\n\n    if (callback !== null) {\n      currentTask.fn = null;\n      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n      callback(didUserCallbackTimeout);\n      currentTime = performance.now();\n\n      if (currentTask === taskQueue[0]) {\n        taskQueue.shift();\n      }\n    } else taskQueue.shift();\n\n    currentTask = taskQueue[0] || null;\n  }\n\n  return currentTask !== null;\n}\n\nconst sharedConfig = {};\n\nfunction setHydrateContext(context) {\n  sharedConfig.context = context;\n}\n\nfunction nextHydrateContext() {\n  return { ...sharedConfig.context,\n    id: `${sharedConfig.context.id}${sharedConfig.context.count++}.`,\n    count: 0\n  };\n}\n\nconst equalFn = (a, b) => a === b;\n\nconst $PROXY = Symbol(\"solid-proxy\");\nconst signalOptions = {\n  equals: equalFn\n};\nlet ERROR = null;\nlet runEffects = runQueue;\nconst NOTPENDING = {};\nconst STALE = 1;\nconst PENDING = 2;\nconst UNOWNED = {\n  owned: null,\n  cleanups: null,\n  context: null,\n  owner: null\n};\nconst [transPending, setTransPending] = /*@__PURE__*/createSignal(false);\nvar Owner = null;\nlet Transition = null;\nlet Scheduler = null;\nlet Listener = null;\nlet Pending = null;\nlet Updates = null;\nlet Effects = null;\nlet ExecCount = 0;\n\nfunction createRoot(fn, detachedOwner) {\n  detachedOwner && (Owner = detachedOwner);\n  const listener = Listener,\n        owner = Owner,\n        root = fn.length === 0 && !false ? UNOWNED : {\n    owned: null,\n    cleanups: null,\n    context: null,\n    owner\n  };\n  Owner = root;\n  Listener = null;\n  let result;\n\n  try {\n    runUpdates(() => result = fn(() => cleanNode(root)), true);\n  } finally {\n    Listener = listener;\n    Owner = owner;\n  }\n\n  return result;\n}\n\nfunction createSignal(value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const s = {\n    value,\n    observers: null,\n    observerSlots: null,\n    pending: NOTPENDING,\n    comparator: options.equals || undefined\n  };\n  return [readSignal.bind(s), value => {\n    if (typeof value === \"function\") {\n      if (Transition && Transition.running && Transition.sources.has(s)) value = value(s.pending !== NOTPENDING ? s.pending : s.tValue);else value = value(s.pending !== NOTPENDING ? s.pending : s.value);\n    }\n\n    return writeSignal(s, value);\n  }];\n}\n\nfunction createComputed(fn, value, options) {\n  const c = createComputation(fn, value, true, STALE);\n  if (Scheduler && Transition && Transition.running) Updates.push(c);else updateComputation(c);\n}\n\nfunction createRenderEffect(fn, value, options) {\n  const c = createComputation(fn, value, false, STALE);\n  if (Scheduler && Transition && Transition.running) Updates.push(c);else updateComputation(c);\n}\n\nfunction createEffect(fn, value, options) {\n  runEffects = runUserEffects;\n  const c = createComputation(fn, value, false, STALE),\n        s = SuspenseContext && lookup(Owner, SuspenseContext.id);\n  if (s) c.suspense = s;\n  c.user = true;\n  Effects && Effects.push(c);\n}\n\nfunction createMemo(fn, value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const c = createComputation(fn, value, true, 0);\n  c.pending = NOTPENDING;\n  c.observers = null;\n  c.observerSlots = null;\n  c.comparator = options.equals || undefined;\n\n  if (Scheduler && Transition && Transition.running) {\n    c.tState = STALE;\n    Updates.push(c);\n  } else updateComputation(c);\n\n  return readSignal.bind(c);\n}\n\nfunction createResource(source, fetcher, options) {\n  if (arguments.length === 2) {\n    if (typeof fetcher === \"object\") {\n      options = fetcher;\n      fetcher = source;\n      source = true;\n    }\n  } else if (arguments.length === 1) {\n    fetcher = source;\n    source = true;\n  }\n\n  const contexts = new Set(),\n        [s, set] = createSignal((options || {}).initialValue),\n        [track, trigger] = createSignal(undefined, {\n    equals: false\n  }),\n        [loading, setLoading] = createSignal(false),\n        [error, setError] = createSignal();\n  let err = undefined,\n      pr = null,\n      initP = null,\n      id = null,\n      loadedUnderTransition = false,\n      dynamic = typeof source === \"function\";\n\n  if (sharedConfig.context) {\n    id = `${sharedConfig.context.id}${sharedConfig.context.count++}`;\n\n    if (sharedConfig.context.loadResource) {\n      initP = sharedConfig.context.loadResource(id);\n    } else if (sharedConfig.resources && id && id in sharedConfig.resources) {\n      initP = sharedConfig.resources[id];\n      delete sharedConfig.resources[id];\n    }\n  }\n\n  function loadEnd(p, v, e) {\n    if (pr === p) {\n      setError(err = e);\n      pr = null;\n\n      if (Transition && p && loadedUnderTransition) {\n        Transition.promises.delete(p);\n        loadedUnderTransition = false;\n        runUpdates(() => {\n          Transition.running = true;\n\n          if (!Transition.promises.size) {\n            Effects.push.apply(Effects, Transition.effects);\n            Transition.effects = [];\n          }\n\n          completeLoad(v);\n        }, false);\n      } else completeLoad(v);\n    }\n\n    return v;\n  }\n\n  function completeLoad(v) {\n    batch(() => {\n      set(() => v);\n      setLoading(false);\n\n      for (const c of contexts.keys()) c.decrement();\n\n      contexts.clear();\n    });\n  }\n\n  function read() {\n    const c = SuspenseContext && lookup(Owner, SuspenseContext.id),\n          v = s();\n    if (err) throw err;\n\n    if (Listener && !Listener.user && c) {\n      createComputed(() => {\n        track();\n\n        if (pr) {\n          if (c.resolved && Transition) Transition.promises.add(pr);else if (!contexts.has(c)) {\n            c.increment();\n            contexts.add(c);\n          }\n        }\n      });\n    }\n\n    return v;\n  }\n\n  function load() {\n    setError(err = undefined);\n    const lookup = dynamic ? source() : source;\n    loadedUnderTransition = Transition && Transition.running;\n\n    if (lookup == null || lookup === false) {\n      loadEnd(pr, untrack(s));\n      return;\n    }\n\n    if (Transition && pr) Transition.promises.delete(pr);\n    const p = initP || untrack(() => fetcher(lookup, s));\n    initP = null;\n\n    if (typeof p !== \"object\" || !(\"then\" in p)) {\n      loadEnd(pr, p);\n      return;\n    }\n\n    pr = p;\n    batch(() => {\n      setLoading(true);\n      trigger();\n    });\n    p.then(v => loadEnd(p, v), e => loadEnd(p, e, e));\n  }\n\n  Object.defineProperties(read, {\n    loading: {\n      get() {\n        return loading();\n      }\n\n    },\n    error: {\n      get() {\n        return error();\n      }\n\n    }\n  });\n  if (dynamic) createComputed(load);else load();\n  return [read, {\n    refetch: load,\n    mutate: set\n  }];\n}\n\nfunction createDeferred(source, options) {\n  let t,\n      timeout = options ? options.timeoutMs : undefined;\n  const node = createComputation(() => {\n    if (!t || !t.fn) t = requestCallback(() => setDeferred(() => node.value), timeout !== undefined ? {\n      timeout\n    } : undefined);\n    return source();\n  }, undefined, true);\n  const [deferred, setDeferred] = createSignal(node.value, options);\n  updateComputation(node);\n  setDeferred(() => node.value);\n  return deferred;\n}\n\nfunction createSelector(source) {\n  let fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : equalFn;\n  let options = arguments.length > 2 ? arguments[2] : undefined;\n  const subs = new Map();\n  const node = createComputation(p => {\n    const v = source();\n\n    for (const key of subs.keys()) if (fn(key, v) || p !== undefined && fn(key, p)) {\n      const l = subs.get(key);\n\n      for (const c of l.values()) {\n        c.state = STALE;\n        if (c.pure) Updates.push(c);else Effects.push(c);\n      }\n    }\n\n    return v;\n  }, undefined, true, STALE);\n  updateComputation(node);\n  return key => {\n    let listener;\n\n    if (listener = Listener) {\n      let l;\n      if (l = subs.get(key)) l.add(listener);else subs.set(key, l = new Set([listener]));\n      onCleanup(() => {\n        l.size > 1 ? l.delete(listener) : subs.delete(key);\n      });\n    }\n\n    return fn(key, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value);\n  };\n}\n\nfunction batch(fn) {\n  if (Pending) return fn();\n  let result;\n  const q = Pending = [];\n\n  try {\n    result = fn();\n  } finally {\n    Pending = null;\n  }\n\n  runUpdates(() => {\n    for (let i = 0; i < q.length; i += 1) {\n      const data = q[i];\n\n      if (data.pending !== NOTPENDING) {\n        const pending = data.pending;\n        data.pending = NOTPENDING;\n        writeSignal(data, pending);\n      }\n    }\n  }, false);\n  return result;\n}\n\nfunction untrack(fn) {\n  let result,\n      listener = Listener;\n  Listener = null;\n  result = fn();\n  Listener = listener;\n  return result;\n}\n\nfunction on(deps, fn, options) {\n  const isArray = Array.isArray(deps);\n  let prevInput;\n  let defer = options && options.defer;\n  return prevValue => {\n    let input;\n\n    if (isArray) {\n      input = [];\n\n      for (let i = 0; i < deps.length; i++) input.push(deps[i]());\n    } else input = deps();\n\n    if (defer) {\n      defer = false;\n      return undefined;\n    }\n\n    const result = untrack(() => fn(input, prevInput, prevValue));\n    prevInput = input;\n    return result;\n  };\n}\n\nfunction onMount(fn) {\n  createEffect(() => untrack(fn));\n}\n\nfunction onCleanup(fn) {\n  if (Owner === null) ;else if (Owner.cleanups === null) Owner.cleanups = [fn];else Owner.cleanups.push(fn);\n  return fn;\n}\n\nfunction onError(fn) {\n  ERROR || (ERROR = Symbol(\"error\"));\n  if (Owner === null) ;else if (Owner.context === null) Owner.context = {\n    [ERROR]: [fn]\n  };else if (!Owner.context[ERROR]) Owner.context[ERROR] = [fn];else Owner.context[ERROR].push(fn);\n}\n\nfunction getListener() {\n  return Listener;\n}\n\nfunction getOwner() {\n  return Owner;\n}\n\nfunction runWithOwner(o, fn) {\n  const prev = Owner;\n  Owner = o;\n\n  try {\n    return fn();\n  } finally {\n    Owner = prev;\n  }\n}\n\nfunction enableScheduling() {\n  let scheduler = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : requestCallback;\n  Scheduler = scheduler;\n}\n\nfunction startTransition(fn, cb) {\n  if (Transition && Transition.running) {\n    fn();\n    cb && Transition.cb.push(cb);\n    return;\n  }\n\n  queueMicrotask(() => {\n    if (Scheduler || SuspenseContext) {\n      Transition || (Transition = {\n        sources: new Set(),\n        effects: [],\n        promises: new Set(),\n        disposed: new Set(),\n        queue: new Set(),\n        running: true,\n        cb: []\n      });\n      cb && Transition.cb.push(cb);\n      Transition.running = true;\n    }\n\n    batch(fn);\n    if (!Scheduler && !SuspenseContext && cb) cb();\n  });\n}\n\nfunction useTransition() {\n  return [transPending, startTransition];\n}\n\nfunction resumeEffects(e) {\n  Effects.push.apply(Effects, e);\n  e.length = 0;\n}\n\nfunction createContext(defaultValue) {\n  const id = Symbol(\"context\");\n  return {\n    id,\n    Provider: createProvider(id),\n    defaultValue\n  };\n}\n\nfunction useContext(context) {\n  return lookup(Owner, context.id) || context.defaultValue;\n}\n\nfunction children(fn) {\n  const children = createMemo(fn);\n  return createMemo(() => resolveChildren(children()));\n}\n\nlet SuspenseContext;\n\nfunction getSuspenseContext() {\n  return SuspenseContext || (SuspenseContext = createContext({}));\n}\n\nfunction readSignal() {\n  const runningTransition = Transition && Transition.running;\n\n  if (this.sources && (!runningTransition && this.state || runningTransition && this.tState)) {\n    const updates = Updates;\n    Updates = null;\n    !runningTransition && this.state === STALE || runningTransition && this.tState === STALE ? updateComputation(this) : lookDownstream(this);\n    Updates = updates;\n  }\n\n  if (Listener) {\n    const sSlot = this.observers ? this.observers.length : 0;\n\n    if (!Listener.sources) {\n      Listener.sources = [this];\n      Listener.sourceSlots = [sSlot];\n    } else {\n      Listener.sources.push(this);\n      Listener.sourceSlots.push(sSlot);\n    }\n\n    if (!this.observers) {\n      this.observers = [Listener];\n      this.observerSlots = [Listener.sources.length - 1];\n    } else {\n      this.observers.push(Listener);\n      this.observerSlots.push(Listener.sources.length - 1);\n    }\n  }\n\n  if (runningTransition && Transition.sources.has(this)) return this.tValue;\n  return this.value;\n}\n\nfunction writeSignal(node, value, isComp) {\n  if (node.comparator) {\n    if (Transition && Transition.running && Transition.sources.has(node)) {\n      if (node.comparator(node.tValue, value)) return value;\n    } else if (node.comparator(node.value, value)) return value;\n  }\n\n  if (Pending) {\n    if (node.pending === NOTPENDING) Pending.push(node);\n    node.pending = value;\n    return value;\n  }\n\n  let TransitionRunning = false;\n\n  if (Transition) {\n    TransitionRunning = Transition.running;\n\n    if (TransitionRunning || !isComp && Transition.sources.has(node)) {\n      Transition.sources.add(node);\n      node.tValue = value;\n    }\n\n    if (!TransitionRunning) node.value = value;\n  } else node.value = value;\n\n  if (node.observers && node.observers.length) {\n    runUpdates(() => {\n      for (let i = 0; i < node.observers.length; i += 1) {\n        const o = node.observers[i];\n        if (TransitionRunning && Transition.disposed.has(o)) continue;\n        if (o.pure) Updates.push(o);else Effects.push(o);\n        if (o.observers && (TransitionRunning && !o.tState || !TransitionRunning && !o.state)) markUpstream(o);\n        if (TransitionRunning) o.tState = STALE;else o.state = STALE;\n      }\n\n      if (Updates.length > 10e5) {\n        Updates = [];\n        if (false) ;\n        throw new Error();\n      }\n    }, false);\n  }\n\n  return value;\n}\n\nfunction updateComputation(node) {\n  if (!node.fn) return;\n  cleanNode(node);\n  const owner = Owner,\n        listener = Listener,\n        time = ExecCount;\n  Listener = Owner = node;\n  runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);\n\n  if (Transition && !Transition.running && Transition.sources.has(node)) {\n    queueMicrotask(() => {\n      runUpdates(() => {\n        Transition && (Transition.running = true);\n        runComputation(node, node.tValue, time);\n      }, false);\n    });\n  }\n\n  Listener = listener;\n  Owner = owner;\n}\n\nfunction runComputation(node, value, time) {\n  let nextValue;\n\n  try {\n    nextValue = node.fn(value);\n  } catch (err) {\n    handleError(err);\n  }\n\n  if (!node.updatedAt || node.updatedAt <= time) {\n    if (node.observers && node.observers.length) {\n      writeSignal(node, nextValue, true);\n    } else if (Transition && Transition.running && node.pure) {\n      Transition.sources.add(node);\n      node.tValue = nextValue;\n    } else node.value = nextValue;\n\n    node.updatedAt = time;\n  }\n}\n\nfunction createComputation(fn, init, pure) {\n  let state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : STALE;\n  let options = arguments.length > 4 ? arguments[4] : undefined;\n  const c = {\n    fn,\n    state: state,\n    updatedAt: null,\n    owned: null,\n    sources: null,\n    sourceSlots: null,\n    cleanups: null,\n    value: init,\n    owner: Owner,\n    context: null,\n    pure\n  };\n\n  if (Transition && Transition.running) {\n    c.state = 0;\n    c.tState = state;\n  }\n\n  if (Owner === null) ;else if (Owner !== UNOWNED) {\n    if (Transition && Transition.running && Owner.pure) {\n      if (!Owner.tOwned) Owner.tOwned = [c];else Owner.tOwned.push(c);\n    } else {\n      if (!Owner.owned) Owner.owned = [c];else Owner.owned.push(c);\n    }\n  }\n  return c;\n}\n\nfunction runTop(node) {\n  const runningTransition = Transition && Transition.running;\n  if (!runningTransition && node.state !== STALE) return node.state = 0;\n  if (runningTransition && node.tState !== STALE) return node.tState = 0;\n  if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);\n  const ancestors = [node];\n\n  while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {\n    if (runningTransition && Transition.disposed.has(node)) return;\n    if (!runningTransition && node.state || runningTransition && node.tState) ancestors.push(node);\n  }\n\n  for (let i = ancestors.length - 1; i >= 0; i--) {\n    node = ancestors[i];\n\n    if (runningTransition) {\n      let top = node,\n          prev = ancestors[i + 1];\n\n      while ((top = top.owner) && top !== prev) {\n        if (Transition.disposed.has(top)) return;\n      }\n    }\n\n    if (!runningTransition && node.state === STALE || runningTransition && node.tState === STALE) {\n      updateComputation(node);\n    } else if (!runningTransition && node.state === PENDING || runningTransition && node.tState === PENDING) {\n      const updates = Updates;\n      Updates = null;\n      lookDownstream(node);\n      Updates = updates;\n    }\n  }\n}\n\nfunction runUpdates(fn, init) {\n  if (Updates) return fn();\n  let wait = false;\n  if (!init) Updates = [];\n  if (Effects) wait = true;else Effects = [];\n  ExecCount++;\n\n  try {\n    fn();\n  } catch (err) {\n    handleError(err);\n  } finally {\n    completeUpdates(wait);\n  }\n}\n\nfunction completeUpdates(wait) {\n  if (Updates) {\n    if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);else runQueue(Updates);\n    Updates = null;\n  }\n\n  if (wait) return;\n  let cbs;\n\n  if (Transition && Transition.running) {\n    if (Transition.promises.size || Transition.queue.size) {\n      Transition.running = false;\n      Transition.effects.push.apply(Transition.effects, Effects);\n      Effects = null;\n      setTransPending(true);\n      return;\n    }\n\n    const sources = Transition.sources;\n    cbs = Transition.cb;\n    Effects.forEach(e => {\n      \"tState\" in e && (e.state = e.tState);\n      delete e.tState;\n    });\n    Transition = null;\n    batch(() => {\n      sources.forEach(v => {\n        v.value = v.tValue;\n\n        if (v.owned) {\n          for (let i = 0, len = v.owned.length; i < len; i++) cleanNode(v.owned[i]);\n        }\n\n        if (v.tOwned) v.owned = v.tOwned;\n        delete v.tValue;\n        delete v.tOwned;\n        v.tState = 0;\n      });\n      setTransPending(false);\n    });\n  }\n\n  if (Effects.length) batch(() => {\n    runEffects(Effects);\n    Effects = null;\n  });else {\n    Effects = null;\n  }\n  if (cbs) cbs.forEach(cb => cb());\n}\n\nfunction runQueue(queue) {\n  for (let i = 0; i < queue.length; i++) runTop(queue[i]);\n}\n\nfunction scheduleQueue(queue) {\n  for (let i = 0; i < queue.length; i++) {\n    const item = queue[i];\n    const tasks = Transition.queue;\n\n    if (!tasks.has(item)) {\n      tasks.add(item);\n      Scheduler(() => {\n        tasks.delete(item);\n        runUpdates(() => {\n          Transition.running = true;\n          runTop(item);\n\n          if (!tasks.size) {\n            Effects.push.apply(Effects, Transition.effects);\n            Transition.effects = [];\n          }\n        }, false);\n        Transition && (Transition.running = false);\n      });\n    }\n  }\n}\n\nfunction runUserEffects(queue) {\n  let i,\n      userLength = 0;\n\n  for (i = 0; i < queue.length; i++) {\n    const e = queue[i];\n    if (!e.user) runTop(e);else queue[userLength++] = e;\n  }\n\n  const resume = queue.length;\n\n  for (i = 0; i < userLength; i++) runTop(queue[i]);\n\n  for (i = resume; i < queue.length; i++) runTop(queue[i]);\n}\n\nfunction lookDownstream(node) {\n  node.state = 0;\n  const runningTransition = Transition && Transition.running;\n\n  for (let i = 0; i < node.sources.length; i += 1) {\n    const source = node.sources[i];\n\n    if (source.sources) {\n      if (!runningTransition && source.state === STALE || runningTransition && source.tState === STALE) runTop(source);else if (!runningTransition && source.state === PENDING || runningTransition && source.tState === PENDING) lookDownstream(source);\n    }\n  }\n}\n\nfunction markUpstream(node) {\n  const runningTransition = Transition && Transition.running;\n\n  for (let i = 0; i < node.observers.length; i += 1) {\n    const o = node.observers[i];\n\n    if (!runningTransition && !o.state || runningTransition && !o.tState) {\n      if (runningTransition) o.tState = PENDING;else o.state = PENDING;\n      if (o.pure) Updates.push(o);else Effects.push(o);\n      o.observers && markUpstream(o);\n    }\n  }\n}\n\nfunction cleanNode(node) {\n  let i;\n\n  if (node.sources) {\n    while (node.sources.length) {\n      const source = node.sources.pop(),\n            index = node.sourceSlots.pop(),\n            obs = source.observers;\n\n      if (obs && obs.length) {\n        const n = obs.pop(),\n              s = source.observerSlots.pop();\n\n        if (index < obs.length) {\n          n.sourceSlots[s] = index;\n          obs[index] = n;\n          source.observerSlots[index] = s;\n        }\n      }\n    }\n  }\n\n  if (Transition && Transition.running && node.pure) {\n    if (node.tOwned) {\n      for (i = 0; i < node.tOwned.length; i++) cleanNode(node.tOwned[i]);\n\n      delete node.tOwned;\n    }\n\n    reset(node, true);\n  } else if (node.owned) {\n    for (i = 0; i < node.owned.length; i++) cleanNode(node.owned[i]);\n\n    node.owned = null;\n  }\n\n  if (node.cleanups) {\n    for (i = 0; i < node.cleanups.length; i++) node.cleanups[i]();\n\n    node.cleanups = null;\n  }\n\n  if (Transition && Transition.running) node.tState = 0;else node.state = 0;\n  node.context = null;\n}\n\nfunction reset(node, top) {\n  if (!top) {\n    node.tState = 0;\n    Transition.disposed.add(node);\n  }\n\n  if (node.owned) {\n    for (let i = 0; i < node.owned.length; i++) reset(node.owned[i]);\n  }\n}\n\nfunction handleError(err) {\n  const fns = ERROR && lookup(Owner, ERROR);\n  if (!fns) throw err;\n  fns.forEach(f => f(err));\n}\n\nfunction lookup(owner, key) {\n  return owner && (owner.context && owner.context[key] || owner.owner && lookup(owner.owner, key));\n}\n\nfunction resolveChildren(children) {\n  if (typeof children === \"function\" && !children.length) return resolveChildren(children());\n\n  if (Array.isArray(children)) {\n    const results = [];\n\n    for (let i = 0; i < children.length; i++) {\n      const result = resolveChildren(children[i]);\n      Array.isArray(result) ? results.push.apply(results, result) : results.push(result);\n    }\n\n    return results;\n  }\n\n  return children;\n}\n\nfunction createProvider(id) {\n  return function provider(props) {\n    let res;\n    createComputed(() => res = untrack(() => {\n      Owner.context = {\n        [id]: props.value\n      };\n      return children(() => props.children);\n    }));\n    return res;\n  };\n}\n\nfunction getSymbol() {\n  const SymbolCopy = Symbol;\n  return SymbolCopy.observable || \"@@observable\";\n}\n\nfunction observable(input) {\n  const $$observable = getSymbol();\n  return {\n    subscribe(observer) {\n      if (!(observer instanceof Object) || observer == null) {\n        throw new TypeError(\"Expected the observer to be an object.\");\n      }\n\n      const handler = \"next\" in observer ? observer.next : observer;\n      let complete = false;\n      createComputed(() => {\n        if (complete) return;\n        const v = input();\n        untrack(() => handler(v));\n      });\n      return {\n        unsubscribe() {\n          complete = true;\n        }\n\n      };\n    },\n\n    [$$observable]() {\n      return this;\n    }\n\n  };\n}\n\nfunction from(producer) {\n  const [s, set] = createSignal(undefined, {\n    equals: false\n  });\n\n  if (\"subscribe\" in producer) {\n    const unsub = producer.subscribe(v => set(() => v));\n    onCleanup(() => \"unsubscribe\" in unsub ? unsub.unsubscribe() : unsub());\n  } else {\n    const clean = producer(set);\n    onCleanup(clean);\n  }\n\n  return s;\n}\n\nconst FALLBACK = Symbol(\"fallback\");\n\nfunction dispose(d) {\n  for (let i = 0; i < d.length; i++) d[i]();\n}\n\nfunction mapArray(list, mapFn) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let items = [],\n      mapped = [],\n      disposers = [],\n      len = 0,\n      indexes = mapFn.length > 1 ? [] : null;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    let newItems = list() || [],\n        i,\n        j;\n    return untrack(() => {\n      let newLen = newItems.length,\n          newIndices,\n          newIndicesNext,\n          temp,\n          tempdisposers,\n          tempIndexes,\n          start,\n          end,\n          newEnd,\n          item;\n\n      if (newLen === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          indexes && (indexes = []);\n        }\n\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n      } else if (len === 0) {\n        mapped = new Array(newLen);\n\n        for (j = 0; j < newLen; j++) {\n          items[j] = newItems[j];\n          mapped[j] = createRoot(mapper);\n        }\n\n        len = newLen;\n      } else {\n        temp = new Array(newLen);\n        tempdisposers = new Array(newLen);\n        indexes && (tempIndexes = new Array(newLen));\n\n        for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++);\n\n        for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--) {\n          temp[newEnd] = mapped[end];\n          tempdisposers[newEnd] = disposers[end];\n          indexes && (tempIndexes[newEnd] = indexes[end]);\n        }\n\n        newIndices = new Map();\n        newIndicesNext = new Array(newEnd + 1);\n\n        for (j = newEnd; j >= start; j--) {\n          item = newItems[j];\n          i = newIndices.get(item);\n          newIndicesNext[j] = i === undefined ? -1 : i;\n          newIndices.set(item, j);\n        }\n\n        for (i = start; i <= end; i++) {\n          item = items[i];\n          j = newIndices.get(item);\n\n          if (j !== undefined && j !== -1) {\n            temp[j] = mapped[i];\n            tempdisposers[j] = disposers[i];\n            indexes && (tempIndexes[j] = indexes[i]);\n            j = newIndicesNext[j];\n            newIndices.set(item, j);\n          } else disposers[i]();\n        }\n\n        for (j = start; j < newLen; j++) {\n          if (j in temp) {\n            mapped[j] = temp[j];\n            disposers[j] = tempdisposers[j];\n\n            if (indexes) {\n              indexes[j] = tempIndexes[j];\n              indexes[j](j);\n            }\n          } else mapped[j] = createRoot(mapper);\n        }\n\n        mapped = mapped.slice(0, len = newLen);\n        items = newItems.slice(0);\n      }\n\n      return mapped;\n    });\n\n    function mapper(disposer) {\n      disposers[j] = disposer;\n\n      if (indexes) {\n        const [s, set] = createSignal(j);\n        indexes[j] = set;\n        return mapFn(newItems[j], s);\n      }\n\n      return mapFn(newItems[j]);\n    }\n  };\n}\n\nfunction indexArray(list, mapFn) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let items = [],\n      mapped = [],\n      disposers = [],\n      signals = [],\n      len = 0,\n      i;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    const newItems = list() || [];\n    return untrack(() => {\n      if (newItems.length === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          signals = [];\n        }\n\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n\n        return mapped;\n      }\n\n      if (items[0] === FALLBACK) {\n        disposers[0]();\n        disposers = [];\n        items = [];\n        mapped = [];\n        len = 0;\n      }\n\n      for (i = 0; i < newItems.length; i++) {\n        if (i < items.length && items[i] !== newItems[i]) {\n          signals[i](() => newItems[i]);\n        } else if (i >= items.length) {\n          mapped[i] = createRoot(mapper);\n        }\n      }\n\n      for (; i < items.length; i++) {\n        disposers[i]();\n      }\n\n      len = signals.length = disposers.length = newItems.length;\n      items = newItems.slice(0);\n      return mapped = mapped.slice(0, len);\n    });\n\n    function mapper(disposer) {\n      disposers[i] = disposer;\n      const [s, set] = createSignal(newItems[i]);\n      signals[i] = set;\n      return mapFn(s, i);\n    }\n  };\n}\n\nfunction createComponent(Comp, props) {\n  if (sharedConfig.context) {\n    const c = sharedConfig.context;\n    setHydrateContext(nextHydrateContext());\n    const r = untrack(() => Comp(props));\n    setHydrateContext(c);\n    return r;\n  }\n\n  return untrack(() => Comp(props));\n}\n\nfunction trueFn() {\n  return true;\n}\n\nconst propTraps = {\n  get(_, property, receiver) {\n    if (property === $PROXY) return receiver;\n    return _.get(property);\n  },\n\n  has(_, property) {\n    return _.has(property);\n  },\n\n  set: trueFn,\n  deleteProperty: trueFn,\n\n  getOwnPropertyDescriptor(_, property) {\n    return {\n      configurable: true,\n      enumerable: true,\n\n      get() {\n        return _.get(property);\n      },\n\n      set: trueFn,\n      deleteProperty: trueFn\n    };\n  },\n\n  ownKeys(_) {\n    return _.keys();\n  }\n\n};\n\nfunction resolveSource(s) {\n  return typeof s === \"function\" ? s() : s;\n}\n\nfunction mergeProps() {\n  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n    sources[_key] = arguments[_key];\n  }\n\n  return new Proxy({\n    get(property) {\n      for (let i = sources.length - 1; i >= 0; i--) {\n        const v = resolveSource(sources[i])[property];\n        if (v !== undefined) return v;\n      }\n    },\n\n    has(property) {\n      for (let i = sources.length - 1; i >= 0; i--) {\n        if (property in resolveSource(sources[i])) return true;\n      }\n\n      return false;\n    },\n\n    keys() {\n      const keys = [];\n\n      for (let i = 0; i < sources.length; i++) keys.push(...Object.keys(resolveSource(sources[i])));\n\n      return [...new Set(keys)];\n    }\n\n  }, propTraps);\n}\n\nfunction splitProps(props) {\n  for (var _len2 = arguments.length, keys = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    keys[_key2 - 1] = arguments[_key2];\n  }\n\n  const blocked = new Set(keys.flat());\n  const descriptors = Object.getOwnPropertyDescriptors(props);\n  const res = keys.map(k => {\n    const clone = {};\n\n    for (let i = 0; i < k.length; i++) {\n      const key = k[i];\n      Object.defineProperty(clone, key, descriptors[key] ? descriptors[key] : {\n        get() {\n          return props[key];\n        },\n\n        set() {\n          return true;\n        }\n\n      });\n    }\n\n    return clone;\n  });\n  res.push(new Proxy({\n    get(property) {\n      return blocked.has(property) ? undefined : props[property];\n    },\n\n    has(property) {\n      return blocked.has(property) ? false : property in props;\n    },\n\n    keys() {\n      return Object.keys(props).filter(k => !blocked.has(k));\n    }\n\n  }, propTraps));\n  return res;\n}\n\nfunction lazy(fn) {\n  let comp;\n\n  const wrap = props => {\n    const ctx = sharedConfig.context;\n\n    if (ctx && sharedConfig.resources) {\n      ctx.count++;\n      const [s, set] = createSignal();\n      fn().then(mod => {\n        setHydrateContext(ctx);\n        set(() => mod.default);\n        setHydrateContext(undefined);\n      });\n      comp = s;\n    } else if (!comp) {\n      const [s] = createResource(() => fn().then(mod => mod.default));\n      comp = s;\n    } else {\n      const c = comp();\n      if (c) return c(props);\n    }\n\n    let Comp;\n    return createMemo(() => (Comp = comp()) && untrack(() => {\n      if (!ctx) return Comp(props);\n      const c = sharedConfig.context;\n      setHydrateContext(ctx);\n      const r = Comp(props);\n      setHydrateContext(c);\n      return r;\n    }));\n  };\n\n  wrap.preload = () => comp || fn().then(mod => comp = () => mod.default);\n\n  return wrap;\n}\n\nlet counter = 0;\n\nfunction createUniqueId() {\n  const ctx = sharedConfig.context;\n  return ctx ? `${ctx.id}${ctx.count++}` : `cl:${counter++}`;\n}\n\nfunction For(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(mapArray(() => props.each, props.children, fallback ? fallback : undefined));\n}\n\nfunction Index(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(indexArray(() => props.each, props.children, fallback ? fallback : undefined));\n}\n\nfunction Show(props) {\n  let strictEqual = false;\n  const condition = createMemo(() => props.when, undefined, {\n    equals: (a, b) => strictEqual ? a === b : !a === !b\n  });\n  return createMemo(() => {\n    const c = condition();\n\n    if (c) {\n      const child = props.children;\n      return (strictEqual = typeof child === \"function\" && child.length > 0) ? untrack(() => child(c)) : child;\n    }\n\n    return props.fallback;\n  });\n}\n\nfunction Switch(props) {\n  let strictEqual = false;\n  const conditions = children(() => props.children),\n        evalConditions = createMemo(() => {\n    let conds = conditions();\n    if (!Array.isArray(conds)) conds = [conds];\n\n    for (let i = 0; i < conds.length; i++) {\n      const c = conds[i].when;\n      if (c) return [i, c, conds[i]];\n    }\n\n    return [-1];\n  }, undefined, {\n    equals: (a, b) => a && a[0] === b[0] && (strictEqual ? a[1] === b[1] : !a[1] === !b[1]) && a[2] === b[2]\n  });\n  return createMemo(() => {\n    const [index, when, cond] = evalConditions();\n    if (index < 0) return props.fallback;\n    const c = cond.children;\n    return (strictEqual = typeof c === \"function\" && c.length > 0) ? untrack(() => c(when)) : c;\n  });\n}\n\nfunction Match(props) {\n  return props;\n}\n\nfunction ErrorBoundary(props) {\n  const [errored, setErrored] = createSignal();\n  let e;\n  return createMemo(() => {\n    if ((e = errored()) != null) {\n      const f = props.fallback;\n      return typeof f === \"function\" && f.length ? untrack(() => f(e, () => setErrored(null))) : f;\n    }\n\n    onError(setErrored);\n    return props.children;\n  });\n}\n\nconst SuspenseListContext = createContext();\n\nfunction SuspenseList(props) {\n  let index = 0,\n      suspenseSetter,\n      showContent,\n      showFallback;\n  const listContext = useContext(SuspenseListContext);\n\n  if (listContext) {\n    const [inFallback, setFallback] = createSignal(false);\n    suspenseSetter = setFallback;\n    [showContent, showFallback] = listContext.register(inFallback);\n  }\n\n  const registry = [],\n        comp = createComponent(SuspenseListContext.Provider, {\n    value: {\n      register: inFallback => {\n        const [showingContent, showContent] = createSignal(false),\n              [showingFallback, showFallback] = createSignal(false);\n        registry[index++] = {\n          inFallback,\n          showContent,\n          showFallback\n        };\n        return [showingContent, showingFallback];\n      }\n    },\n\n    get children() {\n      return props.children;\n    }\n\n  });\n  createComputed(() => {\n    const reveal = props.revealOrder,\n          tail = props.tail,\n          visibleContent = showContent ? showContent() : true,\n          visibleFallback = showFallback ? showFallback() : true,\n          reverse = reveal === \"backwards\";\n\n    if (reveal === \"together\") {\n      const all = registry.every(i => !i.inFallback());\n      suspenseSetter && suspenseSetter(!all);\n      registry.forEach(i => {\n        i.showContent(all && visibleContent);\n        i.showFallback(visibleFallback);\n      });\n      return;\n    }\n\n    let stop = false;\n\n    for (let i = 0, len = registry.length; i < len; i++) {\n      const n = reverse ? len - i - 1 : i,\n            s = registry[n].inFallback();\n\n      if (!stop && !s) {\n        registry[n].showContent(visibleContent);\n        registry[n].showFallback(visibleFallback);\n      } else {\n        const next = !stop;\n        if (next && suspenseSetter) suspenseSetter(true);\n\n        if (!tail || next && tail === \"collapsed\") {\n          registry[n].showFallback(visibleFallback);\n        } else registry[n].showFallback(false);\n\n        stop = true;\n        registry[n].showContent(next);\n      }\n    }\n\n    if (!stop && suspenseSetter) suspenseSetter(false);\n  });\n  return comp;\n}\n\nfunction Suspense(props) {\n  let counter = 0,\n      showContent,\n      showFallback;\n  const [inFallback, setFallback] = createSignal(false),\n        SuspenseContext = getSuspenseContext(),\n        store = {\n    increment: () => {\n      if (++counter === 1) setFallback(true);\n    },\n    decrement: () => {\n      if (--counter === 0) setFallback(false);\n    },\n    inFallback,\n    effects: [],\n    resolved: false\n  },\n        owner = getOwner();\n  const listContext = useContext(SuspenseListContext);\n  if (listContext) [showContent, showFallback] = listContext.register(store.inFallback);\n  let dispose;\n  onCleanup(() => dispose && dispose());\n  return createComponent(SuspenseContext.Provider, {\n    value: store,\n\n    get children() {\n      const rendered = untrack(() => props.children);\n      return createMemo(() => {\n        const inFallback = store.inFallback(),\n              visibleContent = showContent ? showContent() : true,\n              visibleFallback = showFallback ? showFallback() : true;\n        dispose && dispose();\n\n        if (!inFallback && visibleContent) {\n          store.resolved = true;\n          resumeEffects(store.effects);\n          return rendered;\n        }\n\n        if (!visibleFallback) return;\n        return createRoot(disposer => {\n          dispose = disposer;\n          return props.fallback;\n        }, owner);\n      });\n    }\n\n  });\n}\n\nfunction awaitSuspense() {}\n\nlet DEV;\nexport { $PROXY, DEV, ErrorBoundary, For, Index, Match, Show, Suspense, SuspenseList, Switch, awaitSuspense, batch, cancelCallback, children, createComponent, createComputed, createContext, createDeferred, createEffect, createMemo, createRenderEffect, createResource, createRoot, createSelector, createSignal, createUniqueId, enableScheduling, equalFn, from, getListener, getOwner, indexArray, lazy, mapArray, mergeProps, observable, on, onCleanup, onError, onMount, requestCallback, runWithOwner, sharedConfig, splitProps, startTransition, untrack, useContext, useTransition };","map":{"version":3,"sources":["C:/dragon-drop/node_modules/solid-js/dist/solid.js"],"names":["taskIdCounter","isCallbackScheduled","isPerformingWork","taskQueue","currentTask","shouldYieldToHost","yieldInterval","deadline","maxYieldInterval","scheduleCallback","scheduledCallback","maxSigned31BitInt","setupScheduler","channel","MessageChannel","port","port2","postMessage","port1","onmessage","currentTime","performance","now","hasTimeRemaining","hasMoreWork","error","navigator","scheduling","isInputPending","enqueue","task","findIndex","m","n","length","k","cmp","expirationTime","splice","requestCallback","fn","options","startTime","timeout","newTask","id","flushWork","cancelCallback","initialTime","workLoop","callback","didUserCallbackTimeout","shift","sharedConfig","setHydrateContext","context","nextHydrateContext","count","equalFn","a","b","$PROXY","Symbol","signalOptions","equals","ERROR","runEffects","runQueue","NOTPENDING","STALE","PENDING","UNOWNED","owned","cleanups","owner","transPending","setTransPending","createSignal","Owner","Transition","Scheduler","Listener","Pending","Updates","Effects","ExecCount","createRoot","detachedOwner","listener","root","result","runUpdates","cleanNode","value","Object","assign","s","observers","observerSlots","pending","comparator","undefined","readSignal","bind","running","sources","has","tValue","writeSignal","createComputed","c","createComputation","push","updateComputation","createRenderEffect","createEffect","runUserEffects","SuspenseContext","lookup","suspense","user","createMemo","tState","createResource","source","fetcher","arguments","contexts","Set","set","initialValue","track","trigger","loading","setLoading","setError","err","pr","initP","loadedUnderTransition","dynamic","loadResource","resources","loadEnd","p","v","e","promises","delete","size","apply","effects","completeLoad","batch","keys","decrement","clear","read","resolved","add","increment","load","untrack","then","defineProperties","get","refetch","mutate","createDeferred","t","timeoutMs","node","setDeferred","deferred","createSelector","subs","Map","key","l","values","state","pure","onCleanup","q","i","data","on","deps","isArray","Array","prevInput","defer","prevValue","input","onMount","onError","getListener","getOwner","runWithOwner","o","prev","enableScheduling","scheduler","startTransition","cb","queueMicrotask","disposed","queue","useTransition","resumeEffects","createContext","defaultValue","Provider","createProvider","useContext","children","resolveChildren","getSuspenseContext","runningTransition","updates","lookDownstream","sSlot","sourceSlots","isComp","TransitionRunning","markUpstream","Error","time","runComputation","nextValue","handleError","updatedAt","init","tOwned","runTop","inFallback","ancestors","top","wait","completeUpdates","scheduleQueue","cbs","forEach","len","item","tasks","userLength","resume","pop","index","obs","reset","fns","f","results","provider","props","res","getSymbol","SymbolCopy","observable","$$observable","subscribe","observer","TypeError","handler","next","complete","unsubscribe","from","producer","unsub","clean","FALLBACK","dispose","d","mapArray","list","mapFn","items","mapped","disposers","indexes","newItems","j","newLen","newIndices","newIndicesNext","temp","tempdisposers","tempIndexes","start","end","newEnd","fallback","disposer","mapper","Math","min","slice","indexArray","signals","createComponent","Comp","r","trueFn","propTraps","_","property","receiver","deleteProperty","getOwnPropertyDescriptor","configurable","enumerable","ownKeys","resolveSource","mergeProps","Proxy","splitProps","blocked","flat","descriptors","getOwnPropertyDescriptors","map","clone","defineProperty","filter","lazy","comp","wrap","ctx","mod","default","preload","counter","createUniqueId","For","each","Index","Show","strictEqual","condition","when","child","Switch","conditions","evalConditions","conds","cond","Match","ErrorBoundary","errored","setErrored","SuspenseListContext","SuspenseList","suspenseSetter","showContent","showFallback","listContext","setFallback","register","registry","showingContent","showingFallback","reveal","revealOrder","tail","visibleContent","visibleFallback","reverse","all","every","stop","Suspense","store","rendered","awaitSuspense","DEV"],"mappings":"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","sourcesContent":["let taskIdCounter = 1,\n    isCallbackScheduled = false,\n    isPerformingWork = false,\n    taskQueue = [],\n    currentTask = null,\n    shouldYieldToHost = null,\n    yieldInterval = 5,\n    deadline = 0,\n    maxYieldInterval = 300,\n    scheduleCallback = null,\n    scheduledCallback = null;\nconst maxSigned31BitInt = 1073741823;\nfunction setupScheduler() {\n  const channel = new MessageChannel(),\n        port = channel.port2;\n  scheduleCallback = () => port.postMessage(null);\n  channel.port1.onmessage = () => {\n    if (scheduledCallback !== null) {\n      const currentTime = performance.now();\n      deadline = currentTime + yieldInterval;\n      const hasTimeRemaining = true;\n      try {\n        const hasMoreWork = scheduledCallback(hasTimeRemaining, currentTime);\n        if (!hasMoreWork) {\n          scheduledCallback = null;\n        } else port.postMessage(null);\n      } catch (error) {\n        port.postMessage(null);\n        throw error;\n      }\n    }\n  };\n  if (navigator && navigator.scheduling && navigator.scheduling.isInputPending) {\n    const scheduling = navigator.scheduling;\n    shouldYieldToHost = () => {\n      const currentTime = performance.now();\n      if (currentTime >= deadline) {\n        if (scheduling.isInputPending()) {\n          return true;\n        }\n        return currentTime >= maxYieldInterval;\n      } else {\n        return false;\n      }\n    };\n  } else {\n    shouldYieldToHost = () => performance.now() >= deadline;\n  }\n}\nfunction enqueue(taskQueue, task) {\n  function findIndex() {\n    let m = 0;\n    let n = taskQueue.length - 1;\n    while (m <= n) {\n      const k = n + m >> 1;\n      const cmp = task.expirationTime - taskQueue[k].expirationTime;\n      if (cmp > 0) m = k + 1;else if (cmp < 0) n = k - 1;else return k;\n    }\n    return m;\n  }\n  taskQueue.splice(findIndex(), 0, task);\n}\nfunction requestCallback(fn, options) {\n  if (!scheduleCallback) setupScheduler();\n  let startTime = performance.now(),\n      timeout = maxSigned31BitInt;\n  if (options && options.timeout) timeout = options.timeout;\n  const newTask = {\n    id: taskIdCounter++,\n    fn,\n    startTime,\n    expirationTime: startTime + timeout\n  };\n  enqueue(taskQueue, newTask);\n  if (!isCallbackScheduled && !isPerformingWork) {\n    isCallbackScheduled = true;\n    scheduledCallback = flushWork;\n    scheduleCallback();\n  }\n  return newTask;\n}\nfunction cancelCallback(task) {\n  task.fn = null;\n}\nfunction flushWork(hasTimeRemaining, initialTime) {\n  isCallbackScheduled = false;\n  isPerformingWork = true;\n  try {\n    return workLoop(hasTimeRemaining, initialTime);\n  } finally {\n    currentTask = null;\n    isPerformingWork = false;\n  }\n}\nfunction workLoop(hasTimeRemaining, initialTime) {\n  let currentTime = initialTime;\n  currentTask = taskQueue[0] || null;\n  while (currentTask !== null) {\n    if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n      break;\n    }\n    const callback = currentTask.fn;\n    if (callback !== null) {\n      currentTask.fn = null;\n      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n      callback(didUserCallbackTimeout);\n      currentTime = performance.now();\n      if (currentTask === taskQueue[0]) {\n        taskQueue.shift();\n      }\n    } else taskQueue.shift();\n    currentTask = taskQueue[0] || null;\n  }\n  return currentTask !== null;\n}\n\nconst sharedConfig = {};\nfunction setHydrateContext(context) {\n  sharedConfig.context = context;\n}\nfunction nextHydrateContext() {\n  return { ...sharedConfig.context,\n    id: `${sharedConfig.context.id}${sharedConfig.context.count++}.`,\n    count: 0\n  };\n}\n\nconst equalFn = (a, b) => a === b;\nconst $PROXY = Symbol(\"solid-proxy\");\nconst signalOptions = {\n  equals: equalFn\n};\nlet ERROR = null;\nlet runEffects = runQueue;\nconst NOTPENDING = {};\nconst STALE = 1;\nconst PENDING = 2;\nconst UNOWNED = {\n  owned: null,\n  cleanups: null,\n  context: null,\n  owner: null\n};\nconst [transPending, setTransPending] = /*@__PURE__*/createSignal(false);\nvar Owner = null;\nlet Transition = null;\nlet Scheduler = null;\nlet Listener = null;\nlet Pending = null;\nlet Updates = null;\nlet Effects = null;\nlet ExecCount = 0;\nfunction createRoot(fn, detachedOwner) {\n  detachedOwner && (Owner = detachedOwner);\n  const listener = Listener,\n        owner = Owner,\n        root = fn.length === 0 && !false ? UNOWNED : {\n    owned: null,\n    cleanups: null,\n    context: null,\n    owner\n  };\n  Owner = root;\n  Listener = null;\n  let result;\n  try {\n    runUpdates(() => result = fn(() => cleanNode(root)), true);\n  } finally {\n    Listener = listener;\n    Owner = owner;\n  }\n  return result;\n}\nfunction createSignal(value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const s = {\n    value,\n    observers: null,\n    observerSlots: null,\n    pending: NOTPENDING,\n    comparator: options.equals || undefined\n  };\n  return [readSignal.bind(s), value => {\n    if (typeof value === \"function\") {\n      if (Transition && Transition.running && Transition.sources.has(s)) value = value(s.pending !== NOTPENDING ? s.pending : s.tValue);else value = value(s.pending !== NOTPENDING ? s.pending : s.value);\n    }\n    return writeSignal(s, value);\n  }];\n}\nfunction createComputed(fn, value, options) {\n  const c = createComputation(fn, value, true, STALE);\n  if (Scheduler && Transition && Transition.running) Updates.push(c);else updateComputation(c);\n}\nfunction createRenderEffect(fn, value, options) {\n  const c = createComputation(fn, value, false, STALE);\n  if (Scheduler && Transition && Transition.running) Updates.push(c);else updateComputation(c);\n}\nfunction createEffect(fn, value, options) {\n  runEffects = runUserEffects;\n  const c = createComputation(fn, value, false, STALE),\n        s = SuspenseContext && lookup(Owner, SuspenseContext.id);\n  if (s) c.suspense = s;\n  c.user = true;\n  Effects && Effects.push(c);\n}\nfunction createMemo(fn, value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const c = createComputation(fn, value, true, 0);\n  c.pending = NOTPENDING;\n  c.observers = null;\n  c.observerSlots = null;\n  c.comparator = options.equals || undefined;\n  if (Scheduler && Transition && Transition.running) {\n    c.tState = STALE;\n    Updates.push(c);\n  } else updateComputation(c);\n  return readSignal.bind(c);\n}\nfunction createResource(source, fetcher, options) {\n  if (arguments.length === 2) {\n    if (typeof fetcher === \"object\") {\n      options = fetcher;\n      fetcher = source;\n      source = true;\n    }\n  } else if (arguments.length === 1) {\n    fetcher = source;\n    source = true;\n  }\n  const contexts = new Set(),\n        [s, set] = createSignal((options || {}).initialValue),\n        [track, trigger] = createSignal(undefined, {\n    equals: false\n  }),\n        [loading, setLoading] = createSignal(false),\n        [error, setError] = createSignal();\n  let err = undefined,\n      pr = null,\n      initP = null,\n      id = null,\n      loadedUnderTransition = false,\n      dynamic = typeof source === \"function\";\n  if (sharedConfig.context) {\n    id = `${sharedConfig.context.id}${sharedConfig.context.count++}`;\n    if (sharedConfig.context.loadResource) {\n      initP = sharedConfig.context.loadResource(id);\n    } else if (sharedConfig.resources && id && id in sharedConfig.resources) {\n      initP = sharedConfig.resources[id];\n      delete sharedConfig.resources[id];\n    }\n  }\n  function loadEnd(p, v, e) {\n    if (pr === p) {\n      setError(err = e);\n      pr = null;\n      if (Transition && p && loadedUnderTransition) {\n        Transition.promises.delete(p);\n        loadedUnderTransition = false;\n        runUpdates(() => {\n          Transition.running = true;\n          if (!Transition.promises.size) {\n            Effects.push.apply(Effects, Transition.effects);\n            Transition.effects = [];\n          }\n          completeLoad(v);\n        }, false);\n      } else completeLoad(v);\n    }\n    return v;\n  }\n  function completeLoad(v) {\n    batch(() => {\n      set(() => v);\n      setLoading(false);\n      for (const c of contexts.keys()) c.decrement();\n      contexts.clear();\n    });\n  }\n  function read() {\n    const c = SuspenseContext && lookup(Owner, SuspenseContext.id),\n          v = s();\n    if (err) throw err;\n    if (Listener && !Listener.user && c) {\n      createComputed(() => {\n        track();\n        if (pr) {\n          if (c.resolved && Transition) Transition.promises.add(pr);else if (!contexts.has(c)) {\n            c.increment();\n            contexts.add(c);\n          }\n        }\n      });\n    }\n    return v;\n  }\n  function load() {\n    setError(err = undefined);\n    const lookup = dynamic ? source() : source;\n    loadedUnderTransition = Transition && Transition.running;\n    if (lookup == null || lookup === false) {\n      loadEnd(pr, untrack(s));\n      return;\n    }\n    if (Transition && pr) Transition.promises.delete(pr);\n    const p = initP || untrack(() => fetcher(lookup, s));\n    initP = null;\n    if (typeof p !== \"object\" || !(\"then\" in p)) {\n      loadEnd(pr, p);\n      return;\n    }\n    pr = p;\n    batch(() => {\n      setLoading(true);\n      trigger();\n    });\n    p.then(v => loadEnd(p, v), e => loadEnd(p, e, e));\n  }\n  Object.defineProperties(read, {\n    loading: {\n      get() {\n        return loading();\n      }\n    },\n    error: {\n      get() {\n        return error();\n      }\n    }\n  });\n  if (dynamic) createComputed(load);else load();\n  return [read, {\n    refetch: load,\n    mutate: set\n  }];\n}\nfunction createDeferred(source, options) {\n  let t,\n      timeout = options ? options.timeoutMs : undefined;\n  const node = createComputation(() => {\n    if (!t || !t.fn) t = requestCallback(() => setDeferred(() => node.value), timeout !== undefined ? {\n      timeout\n    } : undefined);\n    return source();\n  }, undefined, true);\n  const [deferred, setDeferred] = createSignal(node.value, options);\n  updateComputation(node);\n  setDeferred(() => node.value);\n  return deferred;\n}\nfunction createSelector(source, fn = equalFn, options) {\n  const subs = new Map();\n  const node = createComputation(p => {\n    const v = source();\n    for (const key of subs.keys()) if (fn(key, v) || p !== undefined && fn(key, p)) {\n      const l = subs.get(key);\n      for (const c of l.values()) {\n        c.state = STALE;\n        if (c.pure) Updates.push(c);else Effects.push(c);\n      }\n    }\n    return v;\n  }, undefined, true, STALE);\n  updateComputation(node);\n  return key => {\n    let listener;\n    if (listener = Listener) {\n      let l;\n      if (l = subs.get(key)) l.add(listener);else subs.set(key, l = new Set([listener]));\n      onCleanup(() => {\n        l.size > 1 ? l.delete(listener) : subs.delete(key);\n      });\n    }\n    return fn(key, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value);\n  };\n}\nfunction batch(fn) {\n  if (Pending) return fn();\n  let result;\n  const q = Pending = [];\n  try {\n    result = fn();\n  } finally {\n    Pending = null;\n  }\n  runUpdates(() => {\n    for (let i = 0; i < q.length; i += 1) {\n      const data = q[i];\n      if (data.pending !== NOTPENDING) {\n        const pending = data.pending;\n        data.pending = NOTPENDING;\n        writeSignal(data, pending);\n      }\n    }\n  }, false);\n  return result;\n}\nfunction untrack(fn) {\n  let result,\n      listener = Listener;\n  Listener = null;\n  result = fn();\n  Listener = listener;\n  return result;\n}\nfunction on(deps, fn, options) {\n  const isArray = Array.isArray(deps);\n  let prevInput;\n  let defer = options && options.defer;\n  return prevValue => {\n    let input;\n    if (isArray) {\n      input = [];\n      for (let i = 0; i < deps.length; i++) input.push(deps[i]());\n    } else input = deps();\n    if (defer) {\n      defer = false;\n      return undefined;\n    }\n    const result = untrack(() => fn(input, prevInput, prevValue));\n    prevInput = input;\n    return result;\n  };\n}\nfunction onMount(fn) {\n  createEffect(() => untrack(fn));\n}\nfunction onCleanup(fn) {\n  if (Owner === null) ;else if (Owner.cleanups === null) Owner.cleanups = [fn];else Owner.cleanups.push(fn);\n  return fn;\n}\nfunction onError(fn) {\n  ERROR || (ERROR = Symbol(\"error\"));\n  if (Owner === null) ;else if (Owner.context === null) Owner.context = {\n    [ERROR]: [fn]\n  };else if (!Owner.context[ERROR]) Owner.context[ERROR] = [fn];else Owner.context[ERROR].push(fn);\n}\nfunction getListener() {\n  return Listener;\n}\nfunction getOwner() {\n  return Owner;\n}\nfunction runWithOwner(o, fn) {\n  const prev = Owner;\n  Owner = o;\n  try {\n    return fn();\n  } finally {\n    Owner = prev;\n  }\n}\nfunction enableScheduling(scheduler = requestCallback) {\n  Scheduler = scheduler;\n}\nfunction startTransition(fn, cb) {\n  if (Transition && Transition.running) {\n    fn();\n    cb && Transition.cb.push(cb);\n    return;\n  }\n  queueMicrotask(() => {\n    if (Scheduler || SuspenseContext) {\n      Transition || (Transition = {\n        sources: new Set(),\n        effects: [],\n        promises: new Set(),\n        disposed: new Set(),\n        queue: new Set(),\n        running: true,\n        cb: []\n      });\n      cb && Transition.cb.push(cb);\n      Transition.running = true;\n    }\n    batch(fn);\n    if (!Scheduler && !SuspenseContext && cb) cb();\n  });\n}\nfunction useTransition() {\n  return [transPending, startTransition];\n}\nfunction resumeEffects(e) {\n  Effects.push.apply(Effects, e);\n  e.length = 0;\n}\nfunction createContext(defaultValue) {\n  const id = Symbol(\"context\");\n  return {\n    id,\n    Provider: createProvider(id),\n    defaultValue\n  };\n}\nfunction useContext(context) {\n  return lookup(Owner, context.id) || context.defaultValue;\n}\nfunction children(fn) {\n  const children = createMemo(fn);\n  return createMemo(() => resolveChildren(children()));\n}\nlet SuspenseContext;\nfunction getSuspenseContext() {\n  return SuspenseContext || (SuspenseContext = createContext({}));\n}\nfunction readSignal() {\n  const runningTransition = Transition && Transition.running;\n  if (this.sources && (!runningTransition && this.state || runningTransition && this.tState)) {\n    const updates = Updates;\n    Updates = null;\n    !runningTransition && this.state === STALE || runningTransition && this.tState === STALE ? updateComputation(this) : lookDownstream(this);\n    Updates = updates;\n  }\n  if (Listener) {\n    const sSlot = this.observers ? this.observers.length : 0;\n    if (!Listener.sources) {\n      Listener.sources = [this];\n      Listener.sourceSlots = [sSlot];\n    } else {\n      Listener.sources.push(this);\n      Listener.sourceSlots.push(sSlot);\n    }\n    if (!this.observers) {\n      this.observers = [Listener];\n      this.observerSlots = [Listener.sources.length - 1];\n    } else {\n      this.observers.push(Listener);\n      this.observerSlots.push(Listener.sources.length - 1);\n    }\n  }\n  if (runningTransition && Transition.sources.has(this)) return this.tValue;\n  return this.value;\n}\nfunction writeSignal(node, value, isComp) {\n  if (node.comparator) {\n    if (Transition && Transition.running && Transition.sources.has(node)) {\n      if (node.comparator(node.tValue, value)) return value;\n    } else if (node.comparator(node.value, value)) return value;\n  }\n  if (Pending) {\n    if (node.pending === NOTPENDING) Pending.push(node);\n    node.pending = value;\n    return value;\n  }\n  let TransitionRunning = false;\n  if (Transition) {\n    TransitionRunning = Transition.running;\n    if (TransitionRunning || !isComp && Transition.sources.has(node)) {\n      Transition.sources.add(node);\n      node.tValue = value;\n    }\n    if (!TransitionRunning) node.value = value;\n  } else node.value = value;\n  if (node.observers && node.observers.length) {\n    runUpdates(() => {\n      for (let i = 0; i < node.observers.length; i += 1) {\n        const o = node.observers[i];\n        if (TransitionRunning && Transition.disposed.has(o)) continue;\n        if (o.pure) Updates.push(o);else Effects.push(o);\n        if (o.observers && (TransitionRunning && !o.tState || !TransitionRunning && !o.state)) markUpstream(o);\n        if (TransitionRunning) o.tState = STALE;else o.state = STALE;\n      }\n      if (Updates.length > 10e5) {\n        Updates = [];\n        if (false) ;\n        throw new Error();\n      }\n    }, false);\n  }\n  return value;\n}\nfunction updateComputation(node) {\n  if (!node.fn) return;\n  cleanNode(node);\n  const owner = Owner,\n        listener = Listener,\n        time = ExecCount;\n  Listener = Owner = node;\n  runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);\n  if (Transition && !Transition.running && Transition.sources.has(node)) {\n    queueMicrotask(() => {\n      runUpdates(() => {\n        Transition && (Transition.running = true);\n        runComputation(node, node.tValue, time);\n      }, false);\n    });\n  }\n  Listener = listener;\n  Owner = owner;\n}\nfunction runComputation(node, value, time) {\n  let nextValue;\n  try {\n    nextValue = node.fn(value);\n  } catch (err) {\n    handleError(err);\n  }\n  if (!node.updatedAt || node.updatedAt <= time) {\n    if (node.observers && node.observers.length) {\n      writeSignal(node, nextValue, true);\n    } else if (Transition && Transition.running && node.pure) {\n      Transition.sources.add(node);\n      node.tValue = nextValue;\n    } else node.value = nextValue;\n    node.updatedAt = time;\n  }\n}\nfunction createComputation(fn, init, pure, state = STALE, options) {\n  const c = {\n    fn,\n    state: state,\n    updatedAt: null,\n    owned: null,\n    sources: null,\n    sourceSlots: null,\n    cleanups: null,\n    value: init,\n    owner: Owner,\n    context: null,\n    pure\n  };\n  if (Transition && Transition.running) {\n    c.state = 0;\n    c.tState = state;\n  }\n  if (Owner === null) ;else if (Owner !== UNOWNED) {\n    if (Transition && Transition.running && Owner.pure) {\n      if (!Owner.tOwned) Owner.tOwned = [c];else Owner.tOwned.push(c);\n    } else {\n      if (!Owner.owned) Owner.owned = [c];else Owner.owned.push(c);\n    }\n  }\n  return c;\n}\nfunction runTop(node) {\n  const runningTransition = Transition && Transition.running;\n  if (!runningTransition && node.state !== STALE) return node.state = 0;\n  if (runningTransition && node.tState !== STALE) return node.tState = 0;\n  if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);\n  const ancestors = [node];\n  while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {\n    if (runningTransition && Transition.disposed.has(node)) return;\n    if (!runningTransition && node.state || runningTransition && node.tState) ancestors.push(node);\n  }\n  for (let i = ancestors.length - 1; i >= 0; i--) {\n    node = ancestors[i];\n    if (runningTransition) {\n      let top = node,\n          prev = ancestors[i + 1];\n      while ((top = top.owner) && top !== prev) {\n        if (Transition.disposed.has(top)) return;\n      }\n    }\n    if (!runningTransition && node.state === STALE || runningTransition && node.tState === STALE) {\n      updateComputation(node);\n    } else if (!runningTransition && node.state === PENDING || runningTransition && node.tState === PENDING) {\n      const updates = Updates;\n      Updates = null;\n      lookDownstream(node);\n      Updates = updates;\n    }\n  }\n}\nfunction runUpdates(fn, init) {\n  if (Updates) return fn();\n  let wait = false;\n  if (!init) Updates = [];\n  if (Effects) wait = true;else Effects = [];\n  ExecCount++;\n  try {\n    fn();\n  } catch (err) {\n    handleError(err);\n  } finally {\n    completeUpdates(wait);\n  }\n}\nfunction completeUpdates(wait) {\n  if (Updates) {\n    if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);else runQueue(Updates);\n    Updates = null;\n  }\n  if (wait) return;\n  let cbs;\n  if (Transition && Transition.running) {\n    if (Transition.promises.size || Transition.queue.size) {\n      Transition.running = false;\n      Transition.effects.push.apply(Transition.effects, Effects);\n      Effects = null;\n      setTransPending(true);\n      return;\n    }\n    const sources = Transition.sources;\n    cbs = Transition.cb;\n    Effects.forEach(e => {\n      \"tState\" in e && (e.state = e.tState);\n      delete e.tState;\n    });\n    Transition = null;\n    batch(() => {\n      sources.forEach(v => {\n        v.value = v.tValue;\n        if (v.owned) {\n          for (let i = 0, len = v.owned.length; i < len; i++) cleanNode(v.owned[i]);\n        }\n        if (v.tOwned) v.owned = v.tOwned;\n        delete v.tValue;\n        delete v.tOwned;\n        v.tState = 0;\n      });\n      setTransPending(false);\n    });\n  }\n  if (Effects.length) batch(() => {\n    runEffects(Effects);\n    Effects = null;\n  });else {\n    Effects = null;\n  }\n  if (cbs) cbs.forEach(cb => cb());\n}\nfunction runQueue(queue) {\n  for (let i = 0; i < queue.length; i++) runTop(queue[i]);\n}\nfunction scheduleQueue(queue) {\n  for (let i = 0; i < queue.length; i++) {\n    const item = queue[i];\n    const tasks = Transition.queue;\n    if (!tasks.has(item)) {\n      tasks.add(item);\n      Scheduler(() => {\n        tasks.delete(item);\n        runUpdates(() => {\n          Transition.running = true;\n          runTop(item);\n          if (!tasks.size) {\n            Effects.push.apply(Effects, Transition.effects);\n            Transition.effects = [];\n          }\n        }, false);\n        Transition && (Transition.running = false);\n      });\n    }\n  }\n}\nfunction runUserEffects(queue) {\n  let i,\n      userLength = 0;\n  for (i = 0; i < queue.length; i++) {\n    const e = queue[i];\n    if (!e.user) runTop(e);else queue[userLength++] = e;\n  }\n  const resume = queue.length;\n  for (i = 0; i < userLength; i++) runTop(queue[i]);\n  for (i = resume; i < queue.length; i++) runTop(queue[i]);\n}\nfunction lookDownstream(node) {\n  node.state = 0;\n  const runningTransition = Transition && Transition.running;\n  for (let i = 0; i < node.sources.length; i += 1) {\n    const source = node.sources[i];\n    if (source.sources) {\n      if (!runningTransition && source.state === STALE || runningTransition && source.tState === STALE) runTop(source);else if (!runningTransition && source.state === PENDING || runningTransition && source.tState === PENDING) lookDownstream(source);\n    }\n  }\n}\nfunction markUpstream(node) {\n  const runningTransition = Transition && Transition.running;\n  for (let i = 0; i < node.observers.length; i += 1) {\n    const o = node.observers[i];\n    if (!runningTransition && !o.state || runningTransition && !o.tState) {\n      if (runningTransition) o.tState = PENDING;else o.state = PENDING;\n      if (o.pure) Updates.push(o);else Effects.push(o);\n      o.observers && markUpstream(o);\n    }\n  }\n}\nfunction cleanNode(node) {\n  let i;\n  if (node.sources) {\n    while (node.sources.length) {\n      const source = node.sources.pop(),\n            index = node.sourceSlots.pop(),\n            obs = source.observers;\n      if (obs && obs.length) {\n        const n = obs.pop(),\n              s = source.observerSlots.pop();\n        if (index < obs.length) {\n          n.sourceSlots[s] = index;\n          obs[index] = n;\n          source.observerSlots[index] = s;\n        }\n      }\n    }\n  }\n  if (Transition && Transition.running && node.pure) {\n    if (node.tOwned) {\n      for (i = 0; i < node.tOwned.length; i++) cleanNode(node.tOwned[i]);\n      delete node.tOwned;\n    }\n    reset(node, true);\n  } else if (node.owned) {\n    for (i = 0; i < node.owned.length; i++) cleanNode(node.owned[i]);\n    node.owned = null;\n  }\n  if (node.cleanups) {\n    for (i = 0; i < node.cleanups.length; i++) node.cleanups[i]();\n    node.cleanups = null;\n  }\n  if (Transition && Transition.running) node.tState = 0;else node.state = 0;\n  node.context = null;\n}\nfunction reset(node, top) {\n  if (!top) {\n    node.tState = 0;\n    Transition.disposed.add(node);\n  }\n  if (node.owned) {\n    for (let i = 0; i < node.owned.length; i++) reset(node.owned[i]);\n  }\n}\nfunction handleError(err) {\n  const fns = ERROR && lookup(Owner, ERROR);\n  if (!fns) throw err;\n  fns.forEach(f => f(err));\n}\nfunction lookup(owner, key) {\n  return owner && (owner.context && owner.context[key] || owner.owner && lookup(owner.owner, key));\n}\nfunction resolveChildren(children) {\n  if (typeof children === \"function\" && !children.length) return resolveChildren(children());\n  if (Array.isArray(children)) {\n    const results = [];\n    for (let i = 0; i < children.length; i++) {\n      const result = resolveChildren(children[i]);\n      Array.isArray(result) ? results.push.apply(results, result) : results.push(result);\n    }\n    return results;\n  }\n  return children;\n}\nfunction createProvider(id) {\n  return function provider(props) {\n    let res;\n    createComputed(() => res = untrack(() => {\n      Owner.context = {\n        [id]: props.value\n      };\n      return children(() => props.children);\n    }));\n    return res;\n  };\n}\n\nfunction getSymbol() {\n  const SymbolCopy = Symbol;\n  return SymbolCopy.observable || \"@@observable\";\n}\nfunction observable(input) {\n  const $$observable = getSymbol();\n  return {\n    subscribe(observer) {\n      if (!(observer instanceof Object) || observer == null) {\n        throw new TypeError(\"Expected the observer to be an object.\");\n      }\n      const handler = \"next\" in observer ? observer.next : observer;\n      let complete = false;\n      createComputed(() => {\n        if (complete) return;\n        const v = input();\n        untrack(() => handler(v));\n      });\n      return {\n        unsubscribe() {\n          complete = true;\n        }\n      };\n    },\n    [$$observable]() {\n      return this;\n    }\n  };\n}\nfunction from(producer) {\n  const [s, set] = createSignal(undefined, {\n    equals: false\n  });\n  if (\"subscribe\" in producer) {\n    const unsub = producer.subscribe(v => set(() => v));\n    onCleanup(() => \"unsubscribe\" in unsub ? unsub.unsubscribe() : unsub());\n  } else {\n    const clean = producer(set);\n    onCleanup(clean);\n  }\n  return s;\n}\n\nconst FALLBACK = Symbol(\"fallback\");\nfunction dispose(d) {\n  for (let i = 0; i < d.length; i++) d[i]();\n}\nfunction mapArray(list, mapFn, options = {}) {\n  let items = [],\n      mapped = [],\n      disposers = [],\n      len = 0,\n      indexes = mapFn.length > 1 ? [] : null;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    let newItems = list() || [],\n        i,\n        j;\n    return untrack(() => {\n      let newLen = newItems.length,\n          newIndices,\n          newIndicesNext,\n          temp,\n          tempdisposers,\n          tempIndexes,\n          start,\n          end,\n          newEnd,\n          item;\n      if (newLen === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          indexes && (indexes = []);\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n      }\n      else if (len === 0) {\n        mapped = new Array(newLen);\n        for (j = 0; j < newLen; j++) {\n          items[j] = newItems[j];\n          mapped[j] = createRoot(mapper);\n        }\n        len = newLen;\n      } else {\n        temp = new Array(newLen);\n        tempdisposers = new Array(newLen);\n        indexes && (tempIndexes = new Array(newLen));\n        for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++);\n        for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--) {\n          temp[newEnd] = mapped[end];\n          tempdisposers[newEnd] = disposers[end];\n          indexes && (tempIndexes[newEnd] = indexes[end]);\n        }\n        newIndices = new Map();\n        newIndicesNext = new Array(newEnd + 1);\n        for (j = newEnd; j >= start; j--) {\n          item = newItems[j];\n          i = newIndices.get(item);\n          newIndicesNext[j] = i === undefined ? -1 : i;\n          newIndices.set(item, j);\n        }\n        for (i = start; i <= end; i++) {\n          item = items[i];\n          j = newIndices.get(item);\n          if (j !== undefined && j !== -1) {\n            temp[j] = mapped[i];\n            tempdisposers[j] = disposers[i];\n            indexes && (tempIndexes[j] = indexes[i]);\n            j = newIndicesNext[j];\n            newIndices.set(item, j);\n          } else disposers[i]();\n        }\n        for (j = start; j < newLen; j++) {\n          if (j in temp) {\n            mapped[j] = temp[j];\n            disposers[j] = tempdisposers[j];\n            if (indexes) {\n              indexes[j] = tempIndexes[j];\n              indexes[j](j);\n            }\n          } else mapped[j] = createRoot(mapper);\n        }\n        mapped = mapped.slice(0, len = newLen);\n        items = newItems.slice(0);\n      }\n      return mapped;\n    });\n    function mapper(disposer) {\n      disposers[j] = disposer;\n      if (indexes) {\n        const [s, set] = createSignal(j);\n        indexes[j] = set;\n        return mapFn(newItems[j], s);\n      }\n      return mapFn(newItems[j]);\n    }\n  };\n}\nfunction indexArray(list, mapFn, options = {}) {\n  let items = [],\n      mapped = [],\n      disposers = [],\n      signals = [],\n      len = 0,\n      i;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    const newItems = list() || [];\n    return untrack(() => {\n      if (newItems.length === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          signals = [];\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n        return mapped;\n      }\n      if (items[0] === FALLBACK) {\n        disposers[0]();\n        disposers = [];\n        items = [];\n        mapped = [];\n        len = 0;\n      }\n      for (i = 0; i < newItems.length; i++) {\n        if (i < items.length && items[i] !== newItems[i]) {\n          signals[i](() => newItems[i]);\n        } else if (i >= items.length) {\n          mapped[i] = createRoot(mapper);\n        }\n      }\n      for (; i < items.length; i++) {\n        disposers[i]();\n      }\n      len = signals.length = disposers.length = newItems.length;\n      items = newItems.slice(0);\n      return mapped = mapped.slice(0, len);\n    });\n    function mapper(disposer) {\n      disposers[i] = disposer;\n      const [s, set] = createSignal(newItems[i]);\n      signals[i] = set;\n      return mapFn(s, i);\n    }\n  };\n}\n\nfunction createComponent(Comp, props) {\n  if (sharedConfig.context) {\n    const c = sharedConfig.context;\n    setHydrateContext(nextHydrateContext());\n    const r = untrack(() => Comp(props));\n    setHydrateContext(c);\n    return r;\n  }\n  return untrack(() => Comp(props));\n}\nfunction trueFn() {\n  return true;\n}\nconst propTraps = {\n  get(_, property, receiver) {\n    if (property === $PROXY) return receiver;\n    return _.get(property);\n  },\n  has(_, property) {\n    return _.has(property);\n  },\n  set: trueFn,\n  deleteProperty: trueFn,\n  getOwnPropertyDescriptor(_, property) {\n    return {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return _.get(property);\n      },\n      set: trueFn,\n      deleteProperty: trueFn\n    };\n  },\n  ownKeys(_) {\n    return _.keys();\n  }\n};\nfunction resolveSource(s) {\n  return typeof s === \"function\" ? s() : s;\n}\nfunction mergeProps(...sources) {\n  return new Proxy({\n    get(property) {\n      for (let i = sources.length - 1; i >= 0; i--) {\n        const v = resolveSource(sources[i])[property];\n        if (v !== undefined) return v;\n      }\n    },\n    has(property) {\n      for (let i = sources.length - 1; i >= 0; i--) {\n        if (property in resolveSource(sources[i])) return true;\n      }\n      return false;\n    },\n    keys() {\n      const keys = [];\n      for (let i = 0; i < sources.length; i++) keys.push(...Object.keys(resolveSource(sources[i])));\n      return [...new Set(keys)];\n    }\n  }, propTraps);\n}\nfunction splitProps(props, ...keys) {\n  const blocked = new Set(keys.flat());\n  const descriptors = Object.getOwnPropertyDescriptors(props);\n  const res = keys.map(k => {\n    const clone = {};\n    for (let i = 0; i < k.length; i++) {\n      const key = k[i];\n      Object.defineProperty(clone, key, descriptors[key] ? descriptors[key] : {\n        get() {\n          return props[key];\n        },\n        set() {\n          return true;\n        }\n      });\n    }\n    return clone;\n  });\n  res.push(new Proxy({\n    get(property) {\n      return blocked.has(property) ? undefined : props[property];\n    },\n    has(property) {\n      return blocked.has(property) ? false : property in props;\n    },\n    keys() {\n      return Object.keys(props).filter(k => !blocked.has(k));\n    }\n  }, propTraps));\n  return res;\n}\nfunction lazy(fn) {\n  let comp;\n  const wrap = props => {\n    const ctx = sharedConfig.context;\n    if (ctx && sharedConfig.resources) {\n      ctx.count++;\n      const [s, set] = createSignal();\n      fn().then(mod => {\n        setHydrateContext(ctx);\n        set(() => mod.default);\n        setHydrateContext(undefined);\n      });\n      comp = s;\n    } else if (!comp) {\n      const [s] = createResource(() => fn().then(mod => mod.default));\n      comp = s;\n    } else {\n      const c = comp();\n      if (c) return c(props);\n    }\n    let Comp;\n    return createMemo(() => (Comp = comp()) && untrack(() => {\n      if (!ctx) return Comp(props);\n      const c = sharedConfig.context;\n      setHydrateContext(ctx);\n      const r = Comp(props);\n      setHydrateContext(c);\n      return r;\n    }));\n  };\n  wrap.preload = () => comp || fn().then(mod => comp = () => mod.default);\n  return wrap;\n}\nlet counter = 0;\nfunction createUniqueId() {\n  const ctx = sharedConfig.context;\n  return ctx ? `${ctx.id}${ctx.count++}` : `cl:${counter++}`;\n}\n\nfunction For(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(mapArray(() => props.each, props.children, fallback ? fallback : undefined));\n}\nfunction Index(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(indexArray(() => props.each, props.children, fallback ? fallback : undefined));\n}\nfunction Show(props) {\n  let strictEqual = false;\n  const condition = createMemo(() => props.when, undefined, {\n    equals: (a, b) => strictEqual ? a === b : !a === !b\n  });\n  return createMemo(() => {\n    const c = condition();\n    if (c) {\n      const child = props.children;\n      return (strictEqual = typeof child === \"function\" && child.length > 0) ? untrack(() => child(c)) : child;\n    }\n    return props.fallback;\n  });\n}\nfunction Switch(props) {\n  let strictEqual = false;\n  const conditions = children(() => props.children),\n        evalConditions = createMemo(() => {\n    let conds = conditions();\n    if (!Array.isArray(conds)) conds = [conds];\n    for (let i = 0; i < conds.length; i++) {\n      const c = conds[i].when;\n      if (c) return [i, c, conds[i]];\n    }\n    return [-1];\n  }, undefined, {\n    equals: (a, b) => a && a[0] === b[0] && (strictEqual ? a[1] === b[1] : !a[1] === !b[1]) && a[2] === b[2]\n  });\n  return createMemo(() => {\n    const [index, when, cond] = evalConditions();\n    if (index < 0) return props.fallback;\n    const c = cond.children;\n    return (strictEqual = typeof c === \"function\" && c.length > 0) ? untrack(() => c(when)) : c;\n  });\n}\nfunction Match(props) {\n  return props;\n}\nfunction ErrorBoundary(props) {\n  const [errored, setErrored] = createSignal();\n  let e;\n  return createMemo(() => {\n    if ((e = errored()) != null) {\n      const f = props.fallback;\n      return typeof f === \"function\" && f.length ? untrack(() => f(e, () => setErrored(null))) : f;\n    }\n    onError(setErrored);\n    return props.children;\n  });\n}\n\nconst SuspenseListContext = createContext();\nfunction SuspenseList(props) {\n  let index = 0,\n      suspenseSetter,\n      showContent,\n      showFallback;\n  const listContext = useContext(SuspenseListContext);\n  if (listContext) {\n    const [inFallback, setFallback] = createSignal(false);\n    suspenseSetter = setFallback;\n    [showContent, showFallback] = listContext.register(inFallback);\n  }\n  const registry = [],\n        comp = createComponent(SuspenseListContext.Provider, {\n    value: {\n      register: inFallback => {\n        const [showingContent, showContent] = createSignal(false),\n              [showingFallback, showFallback] = createSignal(false);\n        registry[index++] = {\n          inFallback,\n          showContent,\n          showFallback\n        };\n        return [showingContent, showingFallback];\n      }\n    },\n    get children() {\n      return props.children;\n    }\n  });\n  createComputed(() => {\n    const reveal = props.revealOrder,\n          tail = props.tail,\n          visibleContent = showContent ? showContent() : true,\n          visibleFallback = showFallback ? showFallback() : true,\n          reverse = reveal === \"backwards\";\n    if (reveal === \"together\") {\n      const all = registry.every(i => !i.inFallback());\n      suspenseSetter && suspenseSetter(!all);\n      registry.forEach(i => {\n        i.showContent(all && visibleContent);\n        i.showFallback(visibleFallback);\n      });\n      return;\n    }\n    let stop = false;\n    for (let i = 0, len = registry.length; i < len; i++) {\n      const n = reverse ? len - i - 1 : i,\n            s = registry[n].inFallback();\n      if (!stop && !s) {\n        registry[n].showContent(visibleContent);\n        registry[n].showFallback(visibleFallback);\n      } else {\n        const next = !stop;\n        if (next && suspenseSetter) suspenseSetter(true);\n        if (!tail || next && tail === \"collapsed\") {\n          registry[n].showFallback(visibleFallback);\n        } else registry[n].showFallback(false);\n        stop = true;\n        registry[n].showContent(next);\n      }\n    }\n    if (!stop && suspenseSetter) suspenseSetter(false);\n  });\n  return comp;\n}\nfunction Suspense(props) {\n  let counter = 0,\n      showContent,\n      showFallback;\n  const [inFallback, setFallback] = createSignal(false),\n        SuspenseContext = getSuspenseContext(),\n        store = {\n    increment: () => {\n      if (++counter === 1) setFallback(true);\n    },\n    decrement: () => {\n      if (--counter === 0) setFallback(false);\n    },\n    inFallback,\n    effects: [],\n    resolved: false\n  },\n        owner = getOwner();\n  const listContext = useContext(SuspenseListContext);\n  if (listContext) [showContent, showFallback] = listContext.register(store.inFallback);\n  let dispose;\n  onCleanup(() => dispose && dispose());\n  return createComponent(SuspenseContext.Provider, {\n    value: store,\n    get children() {\n      const rendered = untrack(() => props.children);\n      return createMemo(() => {\n        const inFallback = store.inFallback(),\n              visibleContent = showContent ? showContent() : true,\n              visibleFallback = showFallback ? showFallback() : true;\n        dispose && dispose();\n        if (!inFallback && visibleContent) {\n          store.resolved = true;\n          resumeEffects(store.effects);\n          return rendered;\n        }\n        if (!visibleFallback) return;\n        return createRoot(disposer => {\n          dispose = disposer;\n          return props.fallback;\n        }, owner);\n      });\n    }\n  });\n}\n\nfunction awaitSuspense() {}\nlet DEV;\n\nexport { $PROXY, DEV, ErrorBoundary, For, Index, Match, Show, Suspense, SuspenseList, Switch, awaitSuspense, batch, cancelCallback, children, createComponent, createComputed, createContext, createDeferred, createEffect, createMemo, createRenderEffect, createResource, createRoot, createSelector, createSignal, createUniqueId, enableScheduling, equalFn, from, getListener, getOwner, indexArray, lazy, mapArray, mergeProps, observable, on, onCleanup, onError, onMount, requestCallback, runWithOwner, sharedConfig, splitProps, startTransition, untrack, useContext, useTransition };\n"]},"metadata":{},"sourceType":"module"}