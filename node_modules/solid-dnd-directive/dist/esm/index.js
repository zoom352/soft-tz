import { overrideItemIdKeyNameBeforeInitialisingDndZones as overrideItemIdKeyNameBeforeInitialisingDndZones$1, dndzone as dndzone$1 } from 'svelte-dnd-action';
export { DRAGGED_ELEMENT_ID, SHADOW_ITEM_MARKER_PROPERTY_NAME, SHADOW_PLACEHOLDER_ITEM_ID, SOURCES, TRIGGERS, alertToScreenReader, setDebugMode } from 'svelte-dnd-action';
import { onMount, onCleanup, createEffect, createRenderEffect } from 'solid-js';

function createFlipper(node, durationMS) {
  let idToRect = new Map();
  let idToAnim = new Map();

  function read(ids) {
    idToRect = new Map();
    Array.from(node.children).forEach((child, index) => {
      idToRect.set(ids[index], child.getBoundingClientRect());
    });
  }

  function flip(ids) {
    Array.from(node.children).forEach((child, index) => {
      const id = ids[index];
      const currentRect = child.getBoundingClientRect();
      const prevRect = idToRect.get(id);

      if (prevRect) {
        const transformX = prevRect.left - currentRect.left;
        const transformY = prevRect.top - currentRect.top;

        if (transformX || transformY) {
          const keyFrames = [{
            transform: `translate3d(${transformX}px, ${transformY}px, 0)`
          }, {
            transform: 'translate3d(0, 0, 0)'
          }];
          const animationObj = child.animate(keyFrames, {
            duration: durationMS,
            easing: "ease-out"
          });
          idToAnim.set(id, animationObj);

          animationObj.onfinish = () => idToAnim.delete(id);

          animationObj.oncancel = () => idToAnim.delete(id);
        }
      }
    });
  }

  return {
    read,
    flip
  };
}

const DEFAULT_FLIP_DURATION_MS = 150;
let ID_KEY = "id";
function overrideItemIdKeyNameBeforeInitialisingDndZones(newId) {
  overrideItemIdKeyNameBeforeInitialisingDndZones$1(newId);
  ID_KEY = newId;
}
function dndzone(node, optionsGetter) {
  const options = optionsGetter();
  validateOptions(options);
  const optionsAsGetters = addDefaultOptions(optionsToGetters(options));
  const {
    flipDurationMs: getFlipDurationMs
  } = optionsAsGetters;
  const getItems = optionsAsGetters.items;
  let flipper = undefined;
  onMount(() => {
    const {
      update,
      destroy
    } = dndzone$1(node, gettersToOptions(optionsAsGetters));
    onCleanup(destroy);
    createEffect(function updateOptionsAndTriggerFlip() {
      update(gettersToOptions(optionsAsGetters));
      flipper?.flip(getItems().map(item => item[ID_KEY]));
    });
  });
  createEffect(function updateFlipperWhenFipDurationChanges() {
    flipper = createFlipper(node, getFlipDurationMs());
  });
  createRenderEffect(function storeFlipInformation() {
    function adaptConsider() {
      flipper?.read(getItems().map(item => item[ID_KEY]));
    }

    function adaptFinalize() {
      flipper?.read(getItems().map(item => item[ID_KEY]));
    }

    node.addEventListener('consider', adaptConsider);
    node.addEventListener('finalize', adaptFinalize);
    onCleanup(() => {
      node.removeEventListener('consider', adaptConsider);
      node.removeEventListener('finalize', adaptFinalize);
    });
  });
}
/* Helper functions */

function makeGetter(option) {
  return typeof option === "function" ? option : () => option;
}
/**
 * Converts an object with either getters or values to an object of getters so that all of the element can be treated the same
 */


function optionsToGetters(options) {
  return Object.keys(options).reduce((res, optName) => {
    res[optName] = makeGetter(options[optName]);
    return res;
  }, {});
}

function validateOptions(options) {
  if (typeof options.items !== "function") {
    throw new Error(`dndzone didn't get an items getter, which is a mandatory option in ${JSON.stringify(options)}`);
  }
}

function addDefaultOptions(optionGetters) {
  if (typeof optionGetters.flipDurationMs !== "function") {
    return { ...optionGetters,
      flipDurationMs: () => DEFAULT_FLIP_DURATION_MS
    };
  }

  return optionGetters;
}
/**
 * Calls each getter and maps it to its value (so it can be given to the lib
 */


function gettersToOptions(optionGetters) {
  return Object.keys(optionGetters).reduce((res, optName) => {
    res[optName] = optionGetters[optName]();
    return res;
  }, {});
}

export { dndzone, overrideItemIdKeyNameBeforeInitialisingDndZones };
//# sourceMappingURL=index.js.map
