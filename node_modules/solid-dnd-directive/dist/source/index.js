import { dndzone as dndActionZone, overrideItemIdKeyNameBeforeInitialisingDndZones as overrideId } from "svelte-dnd-action";
import { createEffect, createRenderEffect, onMount, onCleanup } from "solid-js";
import { createFlipper } from "./util/flip";
export { TRIGGERS, SOURCES, SHADOW_ITEM_MARKER_PROPERTY_NAME, SHADOW_PLACEHOLDER_ITEM_ID, DRAGGED_ELEMENT_ID, alertToScreenReader, setDebugMode } from "svelte-dnd-action";
const DEFAULT_FLIP_DURATION_MS = 150;
let ID_KEY = "id";
export function overrideItemIdKeyNameBeforeInitialisingDndZones(newId) {
    overrideId(newId);
    ID_KEY = newId;
}
export function dndzone(node, optionsGetter) {
    const options = optionsGetter();
    validateOptions(options);
    const optionsAsGetters = addDefaultOptions(optionsToGetters(options));
    const { flipDurationMs: getFlipDurationMs } = optionsAsGetters;
    const getItems = optionsAsGetters.items;
    let flipper = undefined;
    onMount(() => {
        const { update, destroy } = dndActionZone(node, gettersToOptions(optionsAsGetters));
        onCleanup(destroy);
        createEffect(function updateOptionsAndTriggerFlip() {
            update(gettersToOptions(optionsAsGetters));
            flipper?.flip(getItems().map(item => item[ID_KEY]));
        });
    });
    createEffect(function updateFlipperWhenFipDurationChanges() {
        flipper = createFlipper(node, getFlipDurationMs());
    });
    createRenderEffect(function storeFlipInformation() {
        function adaptConsider() {
            flipper?.read(getItems().map(item => item[ID_KEY]));
        }
        function adaptFinalize() {
            flipper?.read(getItems().map(item => item[ID_KEY]));
        }
        node.addEventListener('consider', adaptConsider);
        node.addEventListener('finalize', adaptFinalize);
        onCleanup(() => {
            node.removeEventListener('consider', adaptConsider);
            node.removeEventListener('finalize', adaptFinalize);
        });
    });
}
/* Helper functions */
function makeGetter(option) {
    return (typeof option === "function") ? option : () => option;
}
/**
 * Converts an object with either getters or values to an object of getters so that all of the element can be treated the same
 */
function optionsToGetters(options) {
    return Object.keys(options).reduce((res, optName) => { res[optName] = makeGetter(options[optName]); return res; }, {});
}
function validateOptions(options) {
    if (typeof options.items !== "function") {
        throw new Error(`dndzone didn't get an items getter, which is a mandatory option in ${JSON.stringify(options)}`);
    }
}
function addDefaultOptions(optionGetters) {
    if (typeof optionGetters.flipDurationMs !== "function") {
        return { ...optionGetters, flipDurationMs: () => DEFAULT_FLIP_DURATION_MS };
    }
    return optionGetters;
}
/**
 * Calls each getter and maps it to its value (so it can be given to the lib
 */
function gettersToOptions(optionGetters) {
    return Object.keys(optionGetters).reduce((res, optName) => { res[optName] = optionGetters[optName](); return res; }, {});
}
